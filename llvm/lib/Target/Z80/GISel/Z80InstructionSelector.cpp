//===- Z80InstructionSelector.cpp -----------------------------------------===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//
/// \file
/// This file implements the targeting of the InstructionSelector class for
/// Z80.
/// \todo This should be generated by TableGen.
//===----------------------------------------------------------------------===//

#include "MCTargetDesc/Z80MCTargetDesc.h"
#include "Z80.h"
#include "Z80MachineFunctionInfo.h"
#include "Z80RegisterBankInfo.h"
#include "Z80Subtarget.h"
#include "Z80TargetMachine.h"
#include "llvm/CodeGen/GlobalISel/InstructionSelector.h"
#include "llvm/CodeGen/GlobalISel/InstructionSelectorImpl.h"
#include "llvm/CodeGen/MachineJumpTableInfo.h"
#include "llvm/Support/Debug.h"
using namespace llvm;

#define DEBUG_TYPE "Z80-isel"

namespace {

#define GET_GLOBALISEL_PREDICATE_BITSET
#include "Z80GenGlobalISel.inc"
#undef GET_GLOBALISEL_PREDICATE_BITSET

class Z80InstructionSelector : public InstructionSelector {
public:
  Z80InstructionSelector(const Z80TargetMachine &TM, const Z80Subtarget &STI,
                         const Z80RegisterBankInfo &RBI);

  bool select(MachineInstr &I) const;
  bool select(MachineInstr &I) override {
    return static_cast<const Z80InstructionSelector *>(this)->select(I);
  }
  static const char *getName() { return DEBUG_TYPE; }

private:
  /// tblgen-erated 'select' implementation, used as the initial selector for
  /// the patterns that don't require complex C++.
  bool selectImpl(MachineInstr &I, CodeGenCoverage &CoverageInfo) const;

  bool selectConstant(MachineInstr &I, MachineRegisterInfo &MRI) const;
  bool selectTrunc(MachineInstr &I, MachineRegisterInfo &MRI) const;
  bool selectSExt(MachineInstr &I, MachineRegisterInfo &MRI) const;
  bool selectZExt(MachineInstr &I, MachineRegisterInfo &MRI) const;
  bool selectAnyExt(MachineInstr &I, MachineRegisterInfo &MRI) const;
  bool selectLoadStoreOp(MachineInstr &I, MachineRegisterInfo &MRI,
                         MachineFunction &MF) const;
  bool selectFrameIndexOrGep(MachineInstr &I, MachineRegisterInfo &MRI,
                             MachineFunction &MF) const;

  bool selectCopy(MachineInstr &I, MachineRegisterInfo &MRI) const;
  bool selectUnmergeValues(MachineInstr &I, MachineRegisterInfo &MRI,
                           MachineFunction &MF) const;
  bool selectMergeValues(MachineInstr &I, MachineRegisterInfo &MRI,
                         MachineFunction &MF) const;

  Z80::CondCode foldCompare(MachineInstr &I, MachineIRBuilder &MIB,
                            MachineRegisterInfo &MRI) const;
  Z80::CondCode foldExtendedAddSub(MachineInstr &I, MachineIRBuilder &MIB,
                                   MachineRegisterInfo &MRI) const;
  Z80::CondCode foldSetCC(MachineInstr &I, MachineIRBuilder &MIB,
                          MachineRegisterInfo &MRI) const;
  Z80::CondCode foldCond(Register CondReg, MachineIRBuilder &MIB,
                         MachineRegisterInfo &MRI) const;
  bool selectSetCond(MachineInstr &I, MachineRegisterInfo &MRI) const;

  bool selectSelect(MachineInstr &I, MachineRegisterInfo &MRI) const;
  bool selectBrCond(MachineInstr &I, MachineRegisterInfo &MRI) const;
  bool selectBrJT(MachineInstr &I, MachineRegisterInfo &MRI,
                  MachineFunction &MF) const;
  bool selectImplicitDefOrPHI(MachineInstr &I, MachineRegisterInfo &MRI) const;

  ComplexRendererFns selectMem(MachineOperand &Root) const;
  ComplexRendererFns selectOff(MachineOperand &Root) const;

  const TargetRegisterClass *getRegClass(LLT Ty, const RegisterBank &RB) const;
  const TargetRegisterClass *getRegClass(LLT Ty, unsigned Reg,
                                         MachineRegisterInfo &MRI) const;

  const Z80TargetMachine &TM;
  const Z80Subtarget &STI;
  const Z80InstrInfo &TII;
  const Z80RegisterInfo &TRI;
  const Z80RegisterBankInfo &RBI;

#define GET_GLOBALISEL_PREDICATES_DECL
#include "Z80GenGlobalISel.inc"
#undef GET_GLOBALISEL_PREDICATES_DECL

#define GET_GLOBALISEL_TEMPORARIES_DECL
#include "Z80GenGlobalISel.inc"
#undef GET_GLOBALISEL_TEMPORARIES_DECL
};

} // end anonymous namespace

#define GET_GLOBALISEL_IMPL
#include "Z80GenGlobalISel.inc"
#undef GET_GLOBALISEL_IMPL

Z80InstructionSelector::Z80InstructionSelector(const Z80TargetMachine &TM,
                                               const Z80Subtarget &STI,
                                               const Z80RegisterBankInfo &RBI)
    : InstructionSelector(), TM(TM), STI(STI), TII(*STI.getInstrInfo()),
      TRI(*STI.getRegisterInfo()), RBI(RBI),
#define GET_GLOBALISEL_PREDICATES_INIT
#include "Z80GenGlobalISel.inc"
#undef GET_GLOBALISEL_PREDICATES_INIT
#define GET_GLOBALISEL_TEMPORARIES_INIT
#include "Z80GenGlobalISel.inc"
#undef GET_GLOBALISEL_TEMPORARIES_INIT
{
  (void)this->TM;
}

// FIXME: This should be target-independent, inferred from the types declared
// for each class in the bank.
const TargetRegisterClass *
Z80InstructionSelector::getRegClass(LLT Ty, const RegisterBank &RB) const {
  if (RB.getID() == Z80::GPRRegBankID) {
    if (Ty.getSizeInBits() <= 8)
      return &Z80::R8RegClass;
    if (Ty.getSizeInBits() == 16)
      return &Z80::R16RegClass;
    if (Ty.getSizeInBits() == 24)
      return &Z80::R24RegClass;
  }

  llvm_unreachable("Unknown RegBank!");
}

const TargetRegisterClass *
Z80InstructionSelector::getRegClass(LLT Ty, unsigned Reg,
                                    MachineRegisterInfo &MRI) const {
  const RegisterBank &RegBank = *RBI.getRegBank(Reg, MRI, TRI);
  return getRegClass(Ty, RegBank);
}

static int64_t getSubRegIndex(unsigned Width, unsigned Off = 0) {
  switch (Width) {
  case 8:
    switch (Off) {
    case 0: return Z80::sub_low;
    case 8: return Z80::sub_high;
    }
    break;
  case 16:
    switch (Off) {
    case 0: return Z80::sub_short;
    }
    break;
  }
  return Z80::NoSubRegister;
}

static const TargetRegisterClass *getRegClassFromGRPhysReg(Register Reg) {
  assert(Reg.isPhysical());
  for (auto *RC : {&Z80::R8RegClass, &Z80::F8RegClass, &Z80::R16RegClass,
                   &Z80::Z16RegClass, &Z80::R24RegClass, &Z80::Z24RegClass})
    if (RC->contains(Reg))
      return RC;
  llvm_unreachable("Unknown RegClass for PhysReg!");
}

// Set Z80 Opcode and constrain DstReg.
bool Z80InstructionSelector::selectCopy(MachineInstr &I,
                                        MachineRegisterInfo &MRI) const {
  Register DstReg = I.getOperand(0).getReg();
  unsigned DstSize = RBI.getSizeInBits(DstReg, MRI, TRI);
  if (DstSize == 1)
    DstSize = 8;
  const RegisterBank &DstRegBank = *RBI.getRegBank(DstReg, MRI, TRI);

  Register SrcReg = I.getOperand(1).getReg();
  unsigned SrcSize = RBI.getSizeInBits(SrcReg, MRI, TRI);
  if (SrcSize == 1)
    SrcSize = 8;
  const RegisterBank &SrcRegBank = *RBI.getRegBank(SrcReg, MRI, TRI);

  if (DstReg.isPhysical()) {
    assert(I.isCopy() && "Generic operators do not allow physical registers");

    if (DstReg == Z80::F &&
        !RBI.constrainGenericRegister(SrcReg, Z80::F8RegClass, MRI))
      return false;

    if (DstSize > SrcSize && SrcRegBank.getID() == Z80::GPRRegBankID &&
        DstRegBank.getID() == Z80::GPRRegBankID) {

      if (SrcSize != DstSize) {
        // This case can be generated by ABI lowering, perform anyext
        MachineIRBuilder MIB(I);
        I.getOperand(1).setReg(
            MIB.buildInstr(
                   TargetOpcode::INSERT_SUBREG, {DstRC},
                   {MIB.buildInstr(TargetOpcode::IMPLICIT_DEF, {DstRC}, {}),
                    SrcReg, getSubRegIndex(SrcSize)})
                .getReg(0));
      }
    }

    return true;
  }

  assert((!SrcReg.isPhysical() || I.isCopy()) &&
         "No phys reg on generic operators");
  assert((DstSize == SrcSize ||
          // Copies are a means to setup initial types, the number of
          // bits may not exactly match.
          (SrcReg.isPhysical() &&
           DstSize <= RBI.getSizeInBits(SrcReg, MRI, TRI))) &&
         "Copy with different width?!");

  const TargetRegisterClass *DstRC = MRI.getRegClassOrNull(DstReg);
  if (!DstRC)
    DstRC = getRegClass(MRI.getType(DstReg), DstRegBank);

  if (SrcRegBank.getID() == Z80::GPRRegBankID &&
      DstRegBank.getID() == Z80::GPRRegBankID && SrcSize > DstSize &&
      SrcReg.isPhysical()) {
    // Change the physical register to perform truncate.

    const TargetRegisterClass *SrcRC = getRegClassFromGRPhysReg(SrcReg);

    if (DstRC != SrcRC) {
      I.getOperand(1).setSubReg(getSubRegIndex(DstRC));
      I.getOperand(1).substPhysReg(SrcReg, TRI);
    }
  }

  // No need to constrain SrcReg. It will get constrained when
  // we hit another of its use or its defs.
  // Copies do not have constraints.
  const TargetRegisterClass *OldRC = MRI.getRegClassOrNull(DstReg);
  if (!OldRC || !DstRC->hasSubClassEq(OldRC)) {
    if (!RBI.constrainGenericRegister(DstReg, *DstRC, MRI)) {
      LLVM_DEBUG(dbgs() << "Failed to constrain " << TII.getName(I.getOpcode())
                        << " operand\n");
      return false;
    }
  }
  I.setDesc(TII.get(Z80::COPY));
  return true;
}

bool Z80InstructionSelector::select(MachineInstr &I) const {
  assert(I.getParent() && "Instruction should be in a basic block!");
  assert(I.getParent()->getParent() && "Instruction should be in a function!");

  MachineBasicBlock &MBB = *I.getParent();
  MachineFunction &MF = *MBB.getParent();
  MachineRegisterInfo &MRI = MF.getRegInfo();

  unsigned Opc = I.getOpcode();
  if (!isPreISelGenericOpcode(Opc)) {
    switch (I.getOpcode()) {
    case TargetOpcode::COPY:
      return selectCopy(I, MRI);
    case Z80::SetCC:
      return selectSetCond(I, MRI);
    }
    return true;
  }

  assert(I.getNumOperands() == I.getNumExplicitOperands() &&
         "Generic instruction has unexpected implicit operands");

  if (selectImpl(I, *CoverageInfo))
    return true;

  LLVM_DEBUG(dbgs() << " C++ instruction selection: "; I.print(dbgs()));

  // TODO: This should be implemented by tblgen.
  switch (I.getOpcode()) {
  case TargetOpcode::G_CONSTANT:
  case TargetOpcode::G_GLOBAL_VALUE:
  case TargetOpcode::G_JUMP_TABLE:
    return selectConstant(I, MRI);
  case TargetOpcode::G_TRUNC:
    return selectTrunc(I, MRI);
  case TargetOpcode::G_PTRTOINT:
  case TargetOpcode::G_INTTOPTR:
  case TargetOpcode::G_FREEZE:
    return selectCopy(I, MRI);
  case TargetOpcode::G_SEXT:
    return selectSExt(I, MRI);
  case TargetOpcode::G_ZEXT:
    return selectZExt(I, MRI);
  case TargetOpcode::G_ANYEXT:
    return selectAnyExt(I, MRI);
  case TargetOpcode::G_LOAD:
  case TargetOpcode::G_STORE:
    return selectLoadStoreOp(I, MRI, MF);
  case TargetOpcode::G_PTR_ADD:
  case TargetOpcode::G_FRAME_INDEX:
    return selectFrameIndexOrGep(I, MRI, MF);
  case TargetOpcode::G_UNMERGE_VALUES:
    return selectUnmergeValues(I, MRI, MF);
  case TargetOpcode::G_MERGE_VALUES:
    return selectMergeValues(I, MRI, MF);
  case TargetOpcode::G_SELECT:
    return selectSelect(I, MRI);
  case TargetOpcode::G_UADDO:
  case TargetOpcode::G_UADDE:
  case TargetOpcode::G_USUBO:
  case TargetOpcode::G_USUBE:
  case TargetOpcode::G_SADDO:
  case TargetOpcode::G_SADDE:
  case TargetOpcode::G_SSUBO:
  case TargetOpcode::G_SSUBE:
  case TargetOpcode::G_ICMP:
    return selectSetCond(I, MRI);
  case TargetOpcode::G_BRCOND:
    return selectBrCond(I, MRI);
  case TargetOpcode::G_BRINDIRECT:
    I.setDesc(TII.get(STI.is24Bit() ? Z80::JP24r : Z80::JP16r));
    return constrainSelectedInstRegOperands(I, TII, TRI, RBI);
  case TargetOpcode::G_BRJT:
    return selectBrJT(I, MRI, MF);
  case TargetOpcode::G_IMPLICIT_DEF:
  case TargetOpcode::G_PHI:
    return selectImplicitDefOrPHI(I, MRI);
  default:
    return false;
  }
}

bool Z80InstructionSelector::selectConstant(MachineInstr &I,
                                            MachineRegisterInfo &MRI) const {
  assert((I.getOpcode() == TargetOpcode::G_CONSTANT ||
          I.getOpcode() == TargetOpcode::G_GLOBAL_VALUE ||
          I.getOpcode() == TargetOpcode::G_JUMP_TABLE) &&
         "unexpected instruction");

  const Register DefReg = I.getOperand(0).getReg();
  LLT Ty = MRI.getType(DefReg);

  unsigned NewOpc;
  switch (Ty.getSizeInBits()) {
  case 8:
    NewOpc = Z80::LD8ri;
    break;
  case 16:
    NewOpc = Z80::LD16ri;
    break;
  case 24:
    assert(STI.is24Bit() && "Illegal operand size.");
    NewOpc = Z80::LD24ri;
    break;
  default:
    llvm_unreachable("Unsupported type.");
  }

  I.setDesc(TII.get(NewOpc));
  return constrainSelectedInstRegOperands(I, TII, TRI, RBI);
}

bool Z80InstructionSelector::selectTrunc(MachineInstr &I,
                                         MachineRegisterInfo &MRI) const {
  assert((I.getOpcode() == TargetOpcode::G_TRUNC) && "unexpected instruction");

  const Register DstReg = I.getOperand(0).getReg();
  const Register SrcReg = I.getOperand(1).getReg();

  const LLT DstTy = MRI.getType(DstReg);
  const LLT SrcTy = MRI.getType(SrcReg);

  const RegisterBank &DstRB = *RBI.getRegBank(DstReg, MRI, TRI);
  const RegisterBank &SrcRB = *RBI.getRegBank(SrcReg, MRI, TRI);

  const TargetRegisterClass *DstRC = getRegClass(DstTy, DstRB);
  const TargetRegisterClass *SrcRC = getRegClass(SrcTy, SrcRB);

  if (!DstRC || !SrcRC)
    return false;

  unsigned SubIdx = Z80::NoSubRegister;
  if (TRI.getRegSizeInBits(*DstRC) < TRI.getRegSizeInBits(*SrcRC)) {
    SubIdx = getSubRegIndex(TRI.getRegSizeInBits(*DstRC));
    SrcRC = TRI.getSubClassWithSubReg(SrcRC, SubIdx);
  }

  if (!RBI.constrainGenericRegister(SrcReg, *SrcRC, MRI) ||
      !RBI.constrainGenericRegister(DstReg, *DstRC, MRI)) {
    LLVM_DEBUG(dbgs() << "Failed to constrain " << TII.getName(I.getOpcode())
                      << "\n");
    return false;
  }

  I.getOperand(1).setSubReg(SubIdx);

  I.setDesc(TII.get(Z80::COPY));
  return true;
}

bool Z80InstructionSelector::selectSExt(MachineInstr &I,
                                        MachineRegisterInfo &MRI) const {
  assert((I.getOpcode() == TargetOpcode::G_SEXT) && "unexpected instruction");

  const Register DstReg = I.getOperand(0).getReg();
  const Register SrcReg = I.getOperand(1).getReg();

  const LLT DstTy = MRI.getType(DstReg);
  const LLT SrcTy = MRI.getType(SrcReg);

  if (SrcTy != LLT::scalar(1))
    return false;

  MachineIRBuilder MIB(I);

  unsigned FillOpc;
  Register FillReg;
  const TargetRegisterClass *FillRC;
  switch (DstTy.getSizeInBits()) {
  case 8:
    FillOpc = Z80::SBC8ar;
    FillReg = Z80::A;
    FillRC = &Z80::R8RegClass;
    break;
  case 16:
    FillOpc = Z80::SBC16aa;
    FillReg = Z80::HL;
    FillRC = &Z80::R16RegClass;
    break;
  case 24:
    FillOpc = Z80::SBC24aa;
    FillReg = Z80::UHL;
    FillRC = &Z80::R24RegClass;
    break;
  default:
    return false;
  }

  auto Rotate = MIB.buildInstr(Z80::RRC8r, {LLT::scalar(8)}, {SrcReg});
  if (!constrainSelectedInstRegOperands(*Rotate, TII, TRI, RBI))
    return false;
  auto Fill = MIB.buildInstr(FillOpc);
  Fill->findRegisterUseOperand(FillReg)->setIsUndef();
  if (FillOpc == Z80::SBC8ar)
    Fill.addReg(FillReg, RegState::Undef);
  if (!constrainSelectedInstRegOperands(*Fill, TII, TRI, RBI))
    return false;
  auto CopyFromReg = MIB.buildCopy(DstReg, FillReg);
  if (!RBI.constrainGenericRegister(CopyFromReg.getReg(0), *FillRC, MRI))
    return false;

  I.eraseFromParent();
  return true;
}

bool Z80InstructionSelector::selectZExt(MachineInstr &I,
                                        MachineRegisterInfo &MRI) const {
  assert((I.getOpcode() == TargetOpcode::G_ZEXT) && "unexpected instruction");

  Register DstReg = I.getOperand(0).getReg();
  Register SrcReg = I.getOperand(1).getReg();

  if (MRI.getType(SrcReg) != LLT::scalar(1))
    return false;

  MachineIRBuilder MIB(I);

  auto CopyToA = MIB.buildCopy(Z80::A, SrcReg);
  if (!constrainSelectedInstRegOperands(*CopyToA, TII, TRI, RBI))
    return false;
  auto And = MIB.buildInstr(Z80::AND8ai, {}, {int64_t(1)});
  if (!constrainSelectedInstRegOperands(*And, TII, TRI, RBI))
    return false;

  auto CopyFromA = MIB.buildCopy(LLT::scalar(8), Register(Z80::A));
  if (!RBI.constrainGenericRegister(CopyFromA.getReg(0), Z80::R8RegClass, MRI))
    return false;

  auto ZExt = MIB.buildZExtOrTrunc(DstReg, CopyFromA);

  I.eraseFromParent();
  return select(*ZExt);
}

bool Z80InstructionSelector::selectAnyExt(MachineInstr &I,
                                          MachineRegisterInfo &MRI) const {
  assert((I.getOpcode() == TargetOpcode::G_ANYEXT) && "unexpected instruction");

  const Register DstReg = I.getOperand(0).getReg();
  const TargetRegisterClass *DstRC = getRegClass(DstReg, MRI);
  const unsigned DstSize = RBI.getSizeInBits(DstReg, MRI, TRI);

  const Register SrcReg = I.getOperand(1).getReg();
  const TargetRegisterClass *SrcRC = getRegClass(SrcReg, MRI);
  unsigned SrcSize = RBI.getSizeInBits(SrcReg, MRI, TRI);

  const LLT DstTy = MRI.getType(DstReg);
  const LLT SrcTy = MRI.getType(SrcReg);

  const RegisterBank &DstRB = *RBI.getRegBank(DstReg, MRI, TRI);
  const RegisterBank &SrcRB = *RBI.getRegBank(SrcReg, MRI, TRI);

  assert(DstRB.getID() == SrcRB.getID() &&
         "G_ANYEXT input/output on different banks\n");

  assert(DstSize > SrcSize && "G_ANYEXT incorrect operand size");
  if (SrcSize == 1)
    SrcSize = 8;
  assert(DstSize >= SrcSize && "G_ANYEXT incorrect operand size");

  const TargetRegisterClass *DstRC = getRegClass(DstTy, DstRB);
  const TargetRegisterClass *SrcRC = getRegClass(SrcTy, SrcRB);

  if (!RBI.constrainGenericRegister(SrcReg, *SrcRC, MRI) ||
      !RBI.constrainGenericRegister(DstReg, *DstRC, MRI)) {
    LLVM_DEBUG(dbgs() << "Failed to constrain " << TII.getName(I.getOpcode())
                      << " operand\n");
    return false;
  }

  if (DstSize == SrcSize) {
    I.setDesc(TII.get(Z80::COPY));
    return true;
  }

  MachineIRBuilder MIB(I);
  MIB.buildInstr(TargetOpcode::INSERT_SUBREG, {DstReg},
                 {MIB.buildInstr(TargetOpcode::IMPLICIT_DEF, {DstRC}, {}),
                  SrcReg, getSubRegIndex(SrcSize)});
  I.eraseFromParent();
  return true;
}

bool Z80InstructionSelector::selectLoadStoreOp(MachineInstr &I,
                                               MachineRegisterInfo &MRI,
                                               MachineFunction &MF) const {
  bool IsStore = I.getOpcode() == TargetOpcode::G_STORE;
  assert((IsStore || I.getOpcode() == TargetOpcode::G_LOAD) &&
         "unexpected instruction");

  Register DefReg = I.getOperand(0).getReg();
  Register PtrReg = I.getOperand(1).getReg();
  MachineInstr *PtrMI = MRI.getVRegDef(PtrReg);
  LLT Ty = MRI.getType(DefReg);

  I.RemoveOperand(1);
  if (IsStore)
    I.RemoveOperand(0);
  MachineInstrBuilder MIB(MF, I);
  bool IsOff = false;
  int8_t Off = 0;
  if (PtrMI) {
    switch (PtrMI->getOpcode()) {
    case TargetOpcode::G_FRAME_INDEX:
      IsOff = true;
      break;
    case TargetOpcode::G_PTR_ADD:
      if (auto OffConst =
              getConstantVRegVal(PtrMI->getOperand(2).getReg(), MRI)) {
        if (isInt<8>(*OffConst)) {
          IsOff = true;
          Off = *OffConst;
          if (MachineInstr *BaseMI =
                  MRI.getVRegDef(PtrMI->getOperand(1).getReg()))
            if (BaseMI->getOpcode() == TargetOpcode::G_FRAME_INDEX)
              PtrMI = BaseMI;
        }
      }
      break;
    }
  }
  unsigned Opc;
  switch (Ty.getSizeInBits()) {
  case 8:
    Opc = IsOff ? IsStore ? Z80::LD8og : Z80::LD8go
                : IsStore ? Z80::LD8pg : Z80::LD8gp;
    break;
  case 16:
    Opc = STI.has16BitEZ80Ops() ? IsOff ? IsStore ? Z80::LD16or : Z80::LD16ro
                                        : IsStore ? Z80::LD16pr : Z80::LD16rp
                                : IsOff ? IsStore ? Z80::LD88or : Z80::LD88ro
                                        : IsStore ? Z80::LD88pr : Z80::LD88rp;
    break;
  case 24:
    assert(STI.is24Bit() && "Illegal memory access size.");
    Opc = IsOff ? IsStore ? Z80::LD24or : Z80::LD24ro
                : IsStore ? Z80::LD24pr : Z80::LD24rp;
    break;
  default:
    return false;
  }
  I.setDesc(TII.get(Opc));
  if (IsOff)
    MIB.add(PtrMI->getOperand(1)).addImm(Off);
  else
    MIB.addReg(PtrReg);
  if (IsStore) {
    MIB.addReg(DefReg);
    if (IsOff && Ty.getSizeInBits() > 8) {
      // Special handling for LD16/24or as explained in Z80InstrInfo.td.
      auto &MO = I.getOperand(2);
      DefReg = constrainOperandRegClass(MF, TRI, MRI, TII, RBI, I,
                                        *selectGRegClass(ValReg, MRI), MO);
      MO.setReg(DefReg);
    }
  }

  return constrainSelectedInstRegOperands(I, TII, TRI, RBI);
}

bool Z80InstructionSelector::selectFrameIndexOrGep(MachineInstr &I,
                                                   MachineRegisterInfo &MRI,
                                                   MachineFunction &MF) const {
  bool Is24Bit = STI.is24Bit();
  bool HasLEA = STI.hasEZ80Ops();
  unsigned Opc = I.getOpcode();
  assert(
      (Opc == TargetOpcode::G_FRAME_INDEX || Opc == TargetOpcode::G_PTR_ADD) &&
      "unexpected instruction");

  if (Opc == TargetOpcode::G_PTR_ADD) {
    auto Off = getConstantVRegVal(I.getOperand(2).getReg(), MRI);
    if (Off && *Off >= -1 && *Off <= 1) {
      I.RemoveOperand(2);
      if (!*Off) {
        I.setDesc(TII.get(TargetOpcode::COPY));
        return selectCopy(I, MRI);
      }
      I.setDesc(TII.get(*Off == 1 ? Is24Bit ? Z80::INC24r : Z80::INC16r
                                  : Is24Bit ? Z80::DEC24r : Z80::DEC16r));
      return constrainSelectedInstRegOperands(I, TII, TRI, RBI);
    }
    if (!HasLEA || !Off || !isInt<8>(*Off)) {
      I.setDesc(TII.get(Is24Bit ? Z80::ADD24ao : Z80::ADD16ao));
      return constrainSelectedInstRegOperands(I, TII, TRI, RBI);
    }
    I.getOperand(2).ChangeToImmediate(*Off);
  }

  // Use LEA to calculate frame index and GEP
  I.setDesc(TII.get(Is24Bit ? Z80::LEA24ro : Z80::LEA16ro));

  // Make a note if this LEA is illegal.
  if (!HasLEA)
    MF.getInfo<Z80MachineFunctionInfo>()->setHasIllegalLEA();

  if (Opc == TargetOpcode::G_FRAME_INDEX)
    MachineInstrBuilder(MF, I).addImm(0);

  return constrainSelectedInstRegOperands(I, TII, TRI, RBI);
}

bool Z80InstructionSelector::selectUnmergeValues(MachineInstr &I,
                                                 MachineRegisterInfo &MRI,
                                                 MachineFunction &MF) const {
  assert((I.getOpcode() == TargetOpcode::G_UNMERGE_VALUES) &&
         "unexpected instruction");

  switch (MRI.getType(I.getOperand(I.getNumOperands() - 1).getReg())
              .getSizeInBits()) {
  case 16:
    assert(I.getNumOperands() == 3 &&
           MRI.getType(I.getOperand(0).getReg()) == LLT::scalar(8) &&
           MRI.getType(I.getOperand(1).getReg()) == LLT::scalar(8) &&
           "Illegal instruction");
    BuildMI(*I.getParent(), I, I.getDebugLoc(), TII.get(TargetOpcode::COPY))
        .add(I.getOperand(0))
        .addReg(I.getOperand(2).getReg(), 0, Z80::sub_low);
    BuildMI(*I.getParent(), I, I.getDebugLoc(), TII.get(TargetOpcode::COPY))
        .add(I.getOperand(1))
        .addReg(I.getOperand(2).getReg(), 0, Z80::sub_high);
    if (!RBI.constrainGenericRegister(I.getOperand(0).getReg(), Z80::R8RegClass,
                                      MRI) ||
        !RBI.constrainGenericRegister(I.getOperand(1).getReg(), Z80::R8RegClass,
                                      MRI) ||
        !RBI.constrainGenericRegister(
            I.getOperand(2).getReg(),
            *(STI.is24Bit() ? &Z80::R16RegClass : &Z80::G16RegClass), MRI))
      return false;
    break;
  case 24: {
    assert(STI.is24Bit() && "Illegal memory access size.");
    assert(I.getNumOperands() == 4 &&
           MRI.getType(I.getOperand(0).getReg()) == LLT::scalar(8) &&
           MRI.getType(I.getOperand(1).getReg()) == LLT::scalar(8) &&
           MRI.getType(I.getOperand(2).getReg()) == LLT::scalar(8) &&
           "Illegal instruction");
    int FI = MF.getFrameInfo().CreateStackObject(3, Align(1), false);
    BuildMI(*I.getParent(), I, I.getDebugLoc(), TII.get(Z80::LD24or))
        .addFrameIndex(FI)
        .addImm(0)
        .add(I.getOperand(3));
    BuildMI(*I.getParent(), I, I.getDebugLoc(), TII.get(Z80::LD8ro))
        .add(I.getOperand(2))
        .addFrameIndex(FI)
        .addImm(2);
    BuildMI(*I.getParent(), I, I.getDebugLoc(), TII.get(TargetOpcode::COPY))
        .add(I.getOperand(1))
        .addReg(I.getOperand(3).getReg(), 0, Z80::sub_high);
    BuildMI(*I.getParent(), I, I.getDebugLoc(), TII.get(TargetOpcode::COPY))
        .add(I.getOperand(0))
        .addReg(I.getOperand(3).getReg(), 0, Z80::sub_low);
    if (!RBI.constrainGenericRegister(I.getOperand(0).getReg(), Z80::R8RegClass,
                                      MRI) ||
        !RBI.constrainGenericRegister(I.getOperand(1).getReg(), Z80::R8RegClass,
                                      MRI) ||
        !RBI.constrainGenericRegister(I.getOperand(2).getReg(), Z80::R8RegClass,
                                      MRI) ||
        !RBI.constrainGenericRegister(I.getOperand(3).getReg(),
                                      Z80::R24RegClass, MRI))
      return false;
    break;
  }
  default:
    llvm_unreachable("Illegal instruction");
  }
  I.eraseFromParent();
  return true;
}

bool Z80InstructionSelector::selectMergeValues(MachineInstr &I,
                                               MachineRegisterInfo &MRI,
                                               MachineFunction &MF) const {
  assert((I.getOpcode() == TargetOpcode::G_MERGE_VALUES) &&
         "unexpected instruction");
  Register DstReg = I.getOperand(0).getReg();
  MachineInstr *NewI;
  switch (MRI.getType(DstReg).getSizeInBits()) {
  case 16:
    assert(I.getNumOperands() == 3 &&
           MRI.getType(I.getOperand(1).getReg()) == LLT::scalar(8) &&
           MRI.getType(I.getOperand(2).getReg()) == LLT::scalar(8) &&
           "Illegal instruction");

    NewI = BuildMI(*I.getParent(), I, I.getDebugLoc(),
                   TII.get(TargetOpcode::REG_SEQUENCE), DstReg)
               .add(I.getOperand(1))
               .addImm(Z80::sub_low)
               .add(I.getOperand(2))
               .addImm(Z80::sub_high);
    if (!RBI.constrainGenericRegister(
            DstReg, *(STI.is24Bit() ? &Z80::R16RegClass : &Z80::G16RegClass),
            MRI))
      return false;
    break;
  case 24: {
    assert(STI.is24Bit() && "Illegal memory access size.");
    assert(I.getNumOperands() == 4 &&
           MRI.getType(I.getOperand(1).getReg()) == LLT::scalar(8) &&
           MRI.getType(I.getOperand(2).getReg()) == LLT::scalar(8) &&
           MRI.getType(I.getOperand(3).getReg()) == LLT::scalar(8) &&
           "Illegal instruction");
    int FI = MF.getFrameInfo().CreateStackObject(1, Align(1), false);
    auto Store =
        BuildMI(*I.getParent(), I, I.getDebugLoc(), TII.get(Z80::LD8or))
            .addFrameIndex(FI)
            .addImm(0)
            .add(I.getOperand(3));
    if (!constrainSelectedInstRegOperands(*Store, TII, TRI, RBI))
      return false;
    Register Temp1Reg = MRI.createVirtualRegister(&Z80::R24RegClass);
    Register Temp2Reg = MRI.createVirtualRegister(&Z80::R24RegClass);
    BuildMI(*I.getParent(), I, I.getDebugLoc(), TII.get(Z80::LD24ro), Temp1Reg)
        .addFrameIndex(FI)
        .addImm(-2);
    BuildMI(*I.getParent(), I, I.getDebugLoc(), TII.get(Z80::INSERT_SUBREG),
            Temp2Reg)
        .addReg(Temp1Reg)
        .add(I.getOperand(2))
        .addImm(Z80::sub_high);
    NewI = BuildMI(*I.getParent(), I, I.getDebugLoc(),
                   TII.get(Z80::INSERT_SUBREG), DstReg)
               .addReg(Temp2Reg)
               .add(I.getOperand(1))
               .addImm(Z80::sub_low);
    if (!RBI.constrainGenericRegister(DstReg, Z80::R24RegClass, MRI))
      return false;
    break;
  }
  default:
    llvm_unreachable("Illegal instruction");
  }
  if (!constrainSelectedInstRegOperands(*NewI, TII, TRI, RBI))
    return false;
  I.eraseFromParent();
  return true;
}

Z80::CondCode
Z80InstructionSelector::foldCompare(MachineInstr &I, MachineIRBuilder &MIB,
                                    MachineRegisterInfo &MRI) const {
  assert(I.getOpcode() == TargetOpcode::G_ICMP && "unexpected instruction");
  const Function &F = MIB.getMF().getFunction();
  bool OptSize = F.hasOptSize();

  auto Pred = CmpInst::Predicate(I.getOperand(1).getPredicate());
  Register LHSReg = I.getOperand(2).getReg();
  Register RHSReg = I.getOperand(3).getReg();
  LLT OpTy = MRI.getType(LHSReg);
  unsigned OpSize = OpTy.getSizeInBits();
  assert(MRI.getType(I.getOperand(0).getReg()) == LLT::scalar(1) &&
         !OpTy.isVector() && MRI.getType(RHSReg) == OpTy && "Unexpected type");

  bool IsSigned, IsSwapped, IsConst;
  Z80::CondCode CC =
      Z80::GetBranchConditionForPredicate(Pred, IsSigned, IsSwapped, IsConst);
  if (IsSwapped)
    std::swap(LHSReg, RHSReg);

  unsigned Opc, LDIOpc, AddOpc;
  Register Reg;
  switch (OpSize) {
  case 8:
    Opc = Z80::CP8ar;
    Reg = Z80::A;
    break;
  case 16:
    Opc = Z80::SUB16ao;
    LDIOpc = Z80::LD16ri;
    AddOpc = Z80::ADD16ao;
    Reg = Z80::HL;
    break;
  case 24:
    Opc = Z80::SUB24ao;
    LDIOpc = Z80::LD24ri;
    AddOpc = Z80::ADD24ao;
    Reg = Z80::UHL;
    break;
  default:
    return Z80::COND_INVALID;
  }

  if (IsSigned && !OptSize) {
    int64_t Off = 1 << (OpSize - 1);
    if (OpSize == 8) {
      auto CopyRHSToA = MIB.buildCopy(Register(Z80::A), RHSReg);
      if (!constrainSelectedInstRegOperands(*CopyRHSToA, TII, TRI, RBI))
        return Z80::COND_INVALID;
      auto AddRHS = MIB.buildInstr(Z80::ADD8ai, {}, {Off});
      if (!constrainSelectedInstRegOperands(*AddRHS, TII, TRI, RBI))
        return Z80::COND_INVALID;
      auto CopyRHSFromA = MIB.buildCopy(OpTy, Register(Z80::A));
      if (!constrainSelectedInstRegOperands(*CopyRHSFromA, TII, TRI, RBI))
        return Z80::COND_INVALID;
      RHSReg = CopyRHSFromA.getReg(0);
      auto CopyLHSToA = MIB.buildCopy(Register(Z80::A), LHSReg);
      if (!constrainSelectedInstRegOperands(*CopyLHSToA, TII, TRI, RBI))
        return Z80::COND_INVALID;
      auto AddLHS = MIB.buildInstr(Z80::ADD8ai, {}, {Off});
      if (!constrainSelectedInstRegOperands(*AddLHS, TII, TRI, RBI))
        return Z80::COND_INVALID;
      auto CopyLHSFromA = MIB.buildCopy(OpTy, Register(Z80::A));
      if (!constrainSelectedInstRegOperands(*CopyLHSFromA, TII, TRI, RBI))
        return Z80::COND_INVALID;
      LHSReg = CopyLHSFromA.getReg(0);
      if (!RBI.constrainGenericRegister(LHSReg, Z80::R8RegClass, MRI))
        return Z80::COND_INVALID;
    } else {
      auto LDI = MIB.buildInstr(LDIOpc, {OpTy}, {Off});
      if (!constrainSelectedInstRegOperands(*LDI, TII, TRI, RBI))
        return Z80::COND_INVALID;
      auto AddLHS = MIB.buildInstr(AddOpc, {OpTy}, {LHSReg, LDI});
      if (!constrainSelectedInstRegOperands(*AddLHS, TII, TRI, RBI))
        return Z80::COND_INVALID;
      LHSReg = AddLHS.getReg(0);
      auto AddRHS = MIB.buildInstr(AddOpc, {OpTy}, {RHSReg, LDI});
      if (!constrainSelectedInstRegOperands(*AddRHS, TII, TRI, RBI))
        return Z80::COND_INVALID;
      RHSReg = AddRHS.getReg(0);
    }
    switch (CC) {
    default:
      llvm_unreachable("Expected signed condition");
    case Z80::COND_P:
      CC = Z80::COND_NC;
      break;
    case Z80::COND_M:
      CC = Z80::COND_C;
      break;
    }
  }

  auto Copy = MIB.buildCopy(Reg, LHSReg);
  if (!constrainSelectedInstRegOperands(*Copy, TII, TRI, RBI))
    return Z80::COND_INVALID;
  auto Cmp = MIB.buildInstr(Opc, {}, {RHSReg});
  if (!constrainSelectedInstRegOperands(*Cmp, TII, TRI, RBI))
    return Z80::COND_INVALID;
  if (IsSigned && OptSize) {
    LLT s8 = LLT::scalar(8);
    Type *Int8Ty = Type::getInt8Ty(F.getContext());
    Register FlagsReg = MIB.buildCopy(s8, Register(Z80::F)).getReg(0);
    CallLowering::ArgInfo FlagsArg(FlagsReg, Int8Ty);
    Register SignedFlagsReg = MRI.createGenericVirtualRegister(s8);
    CallLowering::ArgInfo SignedFlagsArg(SignedFlagsReg, Int8Ty);
    createLibcall(MIB, RTLIB::SCMP, SignedFlagsArg, FlagsArg);
    MIB.buildCopy(Register(Z80::F), SignedFlagsReg);
    if (!RBI.constrainGenericRegister(FlagsReg, Z80::F8RegClass, MRI) ||
        !RBI.constrainGenericRegister(SignedFlagsReg, Z80::F8RegClass, MRI))
      return Z80::COND_INVALID;
  }
  return CC;
}

Z80::CondCode Z80InstructionSelector::foldExtendedAddSub(
    MachineInstr &I, MachineIRBuilder &MIB, MachineRegisterInfo &MRI) const {
  unsigned Opc = I.getOpcode();
  assert((Opc == TargetOpcode::G_UADDO || Opc == TargetOpcode::G_UADDE ||
          Opc == TargetOpcode::G_USUBO || Opc == TargetOpcode::G_USUBE ||
          Opc == TargetOpcode::G_SADDO || Opc == TargetOpcode::G_SADDE ||
          Opc == TargetOpcode::G_SSUBO || Opc == TargetOpcode::G_SSUBE) &&
         "unexpected instruction");

  bool IsAdd = Opc == TargetOpcode::G_UADDO || Opc == TargetOpcode::G_UADDE ||
               Opc == TargetOpcode::G_SADDO || Opc == TargetOpcode::G_SADDE;
  bool IsExtend = Opc == TargetOpcode::G_UADDE ||
                  Opc == TargetOpcode::G_USUBE ||
                  Opc == TargetOpcode::G_SADDE || Opc == TargetOpcode::G_SSUBE;
  bool IsSigned = Opc == TargetOpcode::G_SADDO ||
                  Opc == TargetOpcode::G_SADDE ||
                  Opc == TargetOpcode::G_SSUBO || Opc == TargetOpcode::G_SSUBE;

  Register DstReg = I.getOperand(0).getReg();
  Register LHSReg = I.getOperand(2).getReg();
  Register RHSReg = I.getOperand(3).getReg();
  LLT OpTy = MRI.getType(DstReg);

  unsigned AddSubOpc;
  Register AddSubReg;
  const TargetRegisterClass *AddSubRC;
  switch (OpTy.getSizeInBits()) {
  case 8:
    AddSubOpc = IsAdd ? Z80::ADC8ar : Z80::SBC8ar;
    AddSubReg = Z80::A;
    AddSubRC = &Z80::R8RegClass;
    break;
  case 16:
    AddSubOpc = IsAdd ? Z80::ADC16ao : Z80::SBC16ao;
    AddSubReg = Z80::HL;
    AddSubRC = &Z80::R16RegClass;
    break;
  case 24:
    AddSubOpc = IsAdd ? Z80::ADC24ao : Z80::SBC24ao;
    AddSubReg = Z80::UHL;
    AddSubRC = &Z80::R24RegClass;
    break;
  default:
    return Z80::COND_INVALID;
  }

  if (IsExtend) {
    Register CarryInReg = I.getOperand(4).getReg();
    Z80::CondCode CC = foldCond(CarryInReg, MIB, MRI);
    if (CC == Z80::COND_INVALID)
      return CC;
    if (CC != Z80::COND_C) {
      auto SetCC = MIB.buildInstr(Z80::SetCC, {LLT::scalar(1)}, {int64_t(CC)});
      if (!RBI.constrainGenericRegister(SetCC.getReg(0), Z80::R8RegClass, MRI))
        return Z80::COND_INVALID;
      auto BitI = MIB.buildInstr(Z80::RRC8r, {LLT::scalar(8)}, {SetCC});
      if (!constrainSelectedInstRegOperands(*BitI, TII, TRI, RBI))
        return Z80::COND_INVALID;
      if (!select(*SetCC))
        return Z80::COND_INVALID;
    }
  } else
    MIB.buildInstr(Z80::RCF);
  MIB.buildCopy(AddSubReg, LHSReg);
  if (!RBI.constrainGenericRegister(LHSReg, *AddSubRC, MRI))
    return Z80::COND_INVALID;
  auto AddSubI = MIB.buildInstr(AddSubOpc, {}, {RHSReg});
  if (!constrainSelectedInstRegOperands(*AddSubI, TII, TRI, RBI))
    return Z80::COND_INVALID;
  if (MIB.getInsertPt() == I) {
    MIB.buildCopy(DstReg, AddSubReg);
    if (!RBI.constrainGenericRegister(DstReg, *AddSubRC, MRI))
      return Z80::COND_INVALID;
  }
  return IsSigned ? Z80::COND_PE : Z80::COND_C;
}

Z80::CondCode
Z80InstructionSelector::foldSetCC(MachineInstr &I, MachineIRBuilder &MIB,
                                  MachineRegisterInfo &MRI) const {
  assert(I.getOpcode() == Z80::SetCC && "unexpected instruction");
  auto CC = Z80::CondCode(I.getOperand(1).getImm());

  if (I == MIB.getInsertPt())
    return CC;

  return Z80::COND_INVALID;
}

Z80::CondCode Z80InstructionSelector::foldCond(Register CondReg,
                                               MachineIRBuilder &MIB,
                                               MachineRegisterInfo &MRI) const {
  assert(MRI.getType(CondReg) == LLT::scalar(1) && "Expected s1 condition");

  MachineInstr *CondDef = nullptr;
  while (MachineInstr *LookthroughDef = MRI.getVRegDef(CondReg)) {
    //if (LookthroughDef != MIB.getInsertPt() && !MRI.hasOneUse(CondReg))
    //  break;
    CondDef = LookthroughDef;
    unsigned Opc = CondDef->getOpcode();
    if (Opc != TargetOpcode::COPY && Opc != TargetOpcode::G_TRUNC)
      break;
    Register SrcReg = CondDef->getOperand(1).getReg();
    if (SrcReg.isPhysical())
      break;
    CondReg = SrcReg;
  }

  Z80::CondCode CC = Z80::COND_INVALID;
  if (CondDef && MIB.getInsertPt() == *CondDef) {
    switch (CondDef->getOpcode()) {
    case TargetOpcode::G_ICMP:
      CC = foldCompare(*CondDef, MIB, MRI);
      break;
    case TargetOpcode::G_UADDO:
    case TargetOpcode::G_UADDE:
    case TargetOpcode::G_USUBO:
    case TargetOpcode::G_USUBE:
    case TargetOpcode::G_SADDO:
    case TargetOpcode::G_SADDE:
    case TargetOpcode::G_SSUBO:
    case TargetOpcode::G_SSUBE:
      CC = foldExtendedAddSub(*CondDef, MIB, MRI);
      break;
    case Z80::SetCC:
      CC = foldSetCC(*CondDef, MIB, MRI);
      break;
    default:
      break;
    }
  }

  if (CC == Z80::COND_INVALID) {
    // Fallback to bit test
    auto BitI = MIB.buildInstr(Z80::BIT8bg, {}, {int64_t(0), CondReg});
    if (constrainSelectedInstRegOperands(*BitI, TII, TRI, RBI))
      CC = Z80::COND_NZ;
  }

  return CC;
}

bool Z80InstructionSelector::selectSetCond(MachineInstr &I,
                                           MachineRegisterInfo &MRI) const {
  Register CondReg = I.getOperand(I.getNumExplicitDefs() - 1).getReg();
  assert(MRI.getType(CondReg) == LLT::scalar(1) && "Expected s1 condition");

  MachineIRBuilder MIB(I);
  Z80::CondCode CC = foldCond(CondReg, MIB, MRI);
  if (CC == Z80::COND_INVALID)
    return false;

  if (MRI.reg_empty(CondReg))
    return true;

  auto TrueI = MIB.buildInstr(Z80::LD8ri, {LLT::scalar(8)}, {int64_t(1)});
  auto FalseI = MIB.buildInstr(Z80::LD8ri, {LLT::scalar(8)}, {int64_t(0)});
  auto SelectI =
      MIB.buildInstr(Z80::Select8, {CondReg}, {TrueI, FalseI, int64_t(CC)});
  I.eraseFromParent();
  return constrainSelectedInstRegOperands(*FalseI, TII, TRI, RBI) &&
         constrainSelectedInstRegOperands(*TrueI, TII, TRI, RBI) &&
         constrainSelectedInstRegOperands(*SelectI, TII, TRI, RBI);
}

bool Z80InstructionSelector::selectSelect(MachineInstr &I,
                                          MachineRegisterInfo &MRI) const {
  assert(I.getOpcode() == TargetOpcode::G_SELECT && "unexpected instruction");

  LLT OpTy = MRI.getType(I.getOperand(2).getReg());
  unsigned Select;
  const TargetRegisterClass *RC;
  switch (OpTy.getSizeInBits()) {
  case 8:
    Select = Z80::Select8;
    RC = &Z80::R8RegClass;
    break;
  case 16:
    Select = Z80::Select16;
    RC = &Z80::R16RegClass;
    break;
  case 24:
    Select = Z80::Select24;
    RC = &Z80::R24RegClass;
    break;
  default:
    return false;
  }

  MachineIRBuilder MIB(I);
  Z80::CondCode CC = foldCond(I.getOperand(1).getReg(), MIB, MRI);
  if (CC == Z80::COND_INVALID)
    return false;

  I.setDesc(TII.get(Select));
  I.getOperand(1).setReg(I.getOperand(2).getReg());
  I.getOperand(2).setReg(I.getOperand(3).getReg());
  I.getOperand(3).ChangeToImmediate(CC);
  return constrainSelectedInstRegOperands(I, TII, TRI, RBI);
}

bool Z80InstructionSelector::selectBrCond(MachineInstr &I,
                                          MachineRegisterInfo &MRI) const {
  assert(I.getOpcode() == TargetOpcode::G_BRCOND && "unexpected instruction");

  MachineIRBuilder MIB(I);
  Z80::CondCode CC = foldCond(I.getOperand(0).getReg(), MIB, MRI);
  if (CC == Z80::COND_INVALID)
    return false;

  MIB.buildInstr(Z80::JQCC).add(I.getOperand(1)).addImm(CC);
  I.eraseFromParent();
  return true;
}

bool Z80InstructionSelector::selectBrJT(MachineInstr &I,
                                        MachineRegisterInfo &MRI,
                                        MachineFunction &MF) const {
  assert((I.getOpcode() == TargetOpcode::G_BRJT) && "unexpected instruction");

  unsigned EntrySize = MF.getJumpTableInfo()->getEntrySize(MF.getDataLayout());
  assert(EntrySize && EntrySize <= 3 &&
         "Jump table entry size is expected to be less than pointer size");

  Register AddrReg = I.getOperand(0).getReg();
  LLT AddrTy = MRI.getType(AddrReg);
  Register IndexReg = I.getOperand(2).getReg();
  MachineIRBuilder MIB(I);

  for (unsigned Factor = 0; Factor != EntrySize; ++Factor) {
    auto Add = MIB.buildInstr(STI.is24Bit() ? Z80::ADD24ao : Z80::ADD16ao,
                              {AddrTy}, {AddrReg, IndexReg});
    if (!constrainSelectedInstRegOperands(*Add, TII, TRI, RBI))
      return false;
    AddrReg = Add.getReg(0);
  }

  auto Load = MIB.buildInstr(STI.is24Bit()
                                 ? Z80::LD24rp
                                 : STI.hasEZ80Ops() ? Z80::LD16rp : Z80::LD88rp,
                             {AddrTy}, {AddrReg});
  if (!constrainSelectedInstRegOperands(*Load, TII, TRI, RBI))
    return false;

  auto Jump =
      MIB.buildInstr(STI.is24Bit() ? Z80::JP24r : Z80::JP16r, {}, {Load});
  if (!constrainSelectedInstRegOperands(*Jump, TII, TRI, RBI))
    return false;

  I.eraseFromParent();
  return true;
}

bool Z80InstructionSelector::selectImplicitDefOrPHI(
    MachineInstr &I, MachineRegisterInfo &MRI) const {
  assert((I.getOpcode() == TargetOpcode::G_IMPLICIT_DEF ||
          I.getOpcode() == TargetOpcode::G_PHI) &&
         "unexpected instruction");

  Register DstReg = I.getOperand(0).getReg();

  if (!MRI.getRegClassOrNull(DstReg)) {
    const LLT DstTy = MRI.getType(DstReg);
    const TargetRegisterClass *RC = getRegClass(DstTy, DstReg, MRI);

    if (!RBI.constrainGenericRegister(DstReg, *RC, MRI))
      return false;
  }

  if (I.getOpcode() == TargetOpcode::G_IMPLICIT_DEF)
    I.setDesc(TII.get(Z80::IMPLICIT_DEF));
  else
    I.setDesc(TII.get(Z80::PHI));

  return true;
}

InstructionSelector::ComplexRendererFns
Z80InstructionSelector::selectMem(MachineOperand &MO) const {
  llvm_unreachable("Unimplemented!");
}

InstructionSelector::ComplexRendererFns
Z80InstructionSelector::selectOff(MachineOperand &MO) const {
  llvm_unreachable("Unimplemented!");
}

InstructionSelector *
llvm::createZ80InstructionSelector(const Z80TargetMachine &TM,
                                   Z80Subtarget &Subtarget,
                                   Z80RegisterBankInfo &RBI) {
  return new Z80InstructionSelector(TM, Subtarget, RBI);
}
