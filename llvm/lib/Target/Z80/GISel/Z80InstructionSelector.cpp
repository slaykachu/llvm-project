//===- Z80InstructionSelector.cpp -----------------------------------------===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//
/// \file
/// This file implements the targeting of the InstructionSelector class for
/// Z80.
/// \todo This should be generated by TableGen.
//===----------------------------------------------------------------------===//

#include "MCTargetDesc/Z80MCTargetDesc.h"
#include "Z80.h"
#include "Z80MachineFunctionInfo.h"
#include "Z80RegisterBankInfo.h"
#include "Z80Subtarget.h"
#include "Z80TargetMachine.h"
#include "llvm/CodeGen/GlobalISel/InstructionSelector.h"
#include "llvm/CodeGen/GlobalISel/InstructionSelectorImpl.h"
#include "llvm/CodeGen/GlobalISel/MIPatternMatch.h"
#include "llvm/CodeGen/MachineJumpTableInfo.h"
#include "llvm/Support/Debug.h"

using namespace llvm;
using namespace MIPatternMatch;

#define DEBUG_TYPE "Z80-isel"

namespace {

#define GET_GLOBALISEL_PREDICATE_BITSET
#include "Z80GenGlobalISel.inc"
#undef GET_GLOBALISEL_PREDICATE_BITSET

class Z80InstructionSelector : public InstructionSelector {
public:
  Z80InstructionSelector(const Z80TargetMachine &TM, const Z80Subtarget &STI,
                         const Z80RegisterBankInfo &RBI);

  bool select(MachineInstr &I) const;
  bool select(MachineInstr &I) override {
    return static_cast<const Z80InstructionSelector *>(this)->select(I);
  }
  static const char *getName() { return DEBUG_TYPE; }

private:
  /// tblgen-erated 'select' implementation, used as the initial selector for
  /// the patterns that don't require complex C++.
  bool selectImpl(MachineInstr &I, CodeGenCoverage &CoverageInfo) const;

  bool selectConstant(MachineInstr &I, MachineRegisterInfo &MRI) const;
  bool selectTrunc(MachineInstr &I, MachineRegisterInfo &MRI) const;
  bool selectSExt(MachineInstr &I, MachineRegisterInfo &MRI) const;
  bool selectZExt(MachineInstr &I, MachineRegisterInfo &MRI) const;
  bool selectAnyExt(MachineInstr &I, MachineRegisterInfo &MRI) const;
  bool selectLoadStore(MachineInstr &I, MachineRegisterInfo &MRI,
                       MachineFunction &MF) const;
  bool selectFrameIndexOrGep(MachineInstr &I, MachineRegisterInfo &MRI,
                             MachineFunction &MF) const;

  bool selectCopy(MachineInstr &I, MachineRegisterInfo &MRI) const;
  bool selectUnmergeValues(MachineInstr &I, MachineRegisterInfo &MRI,
                           MachineFunction &MF) const;
  bool selectMergeValues(MachineInstr &I, MachineRegisterInfo &MRI,
                         MachineFunction &MF) const;

  Z80::CondCode foldCompare(MachineInstr &I, MachineIRBuilder &MIB,
                            MachineRegisterInfo &MRI) const;
  Z80::CondCode foldExtendedAddSub(MachineInstr &I, MachineIRBuilder &MIB,
                                   MachineRegisterInfo &MRI) const;
  Z80::CondCode foldSetCC(MachineInstr &I, MachineIRBuilder &MIB,
                          MachineRegisterInfo &MRI) const;
  Z80::CondCode foldCond(Register CondReg, MachineIRBuilder &MIB,
                         MachineRegisterInfo &MRI) const;
  bool selectShift(MachineInstr &I, MachineRegisterInfo &MRI) const;
  bool selectFunnelShift(MachineInstr &I, MachineRegisterInfo &MRI) const;
  bool selectSetCond(MachineInstr &I, MachineRegisterInfo &MRI) const;

  bool selectSelect(MachineInstr &I, MachineRegisterInfo &MRI) const;
  bool selectBrCond(MachineInstr &I, MachineRegisterInfo &MRI) const;
  bool selectBrJT(MachineInstr &I, MachineRegisterInfo &MRI,
                  MachineFunction &MF) const;
  bool selectImplicitDefOrPHI(MachineInstr &I, MachineRegisterInfo &MRI) const;

  ComplexRendererFns selectMem(MachineOperand &Root) const;
  ComplexRendererFns selectOff(MachineOperand &Root) const;

  const TargetRegisterClass *getRegClass(LLT Ty, const RegisterBank &RB) const;
  const TargetRegisterClass *getRegClass(LLT Ty, unsigned Reg,
                                         MachineRegisterInfo &MRI) const;

  const Z80TargetMachine &TM;
  const Z80Subtarget &STI;
  const Z80InstrInfo &TII;
  const Z80RegisterInfo &TRI;
  const Z80RegisterBankInfo &RBI;

#define GET_GLOBALISEL_PREDICATES_DECL
#include "Z80GenGlobalISel.inc"
#undef GET_GLOBALISEL_PREDICATES_DECL

#define GET_GLOBALISEL_TEMPORARIES_DECL
#include "Z80GenGlobalISel.inc"
#undef GET_GLOBALISEL_TEMPORARIES_DECL
};

} // end anonymous namespace

#define GET_GLOBALISEL_IMPL
#include "Z80GenGlobalISel.inc"
#undef GET_GLOBALISEL_IMPL

Z80InstructionSelector::Z80InstructionSelector(const Z80TargetMachine &TM,
                                               const Z80Subtarget &STI,
                                               const Z80RegisterBankInfo &RBI)
    : InstructionSelector(), TM(TM), STI(STI), TII(*STI.getInstrInfo()),
      TRI(*STI.getRegisterInfo()), RBI(RBI),
#define GET_GLOBALISEL_PREDICATES_INIT
#include "Z80GenGlobalISel.inc"
#undef GET_GLOBALISEL_PREDICATES_INIT
#define GET_GLOBALISEL_TEMPORARIES_INIT
#include "Z80GenGlobalISel.inc"
#undef GET_GLOBALISEL_TEMPORARIES_INIT
{
  (void)this->TM;
}

// FIXME: This should be target-independent, inferred from the types declared
// for each class in the bank.
const TargetRegisterClass *
Z80InstructionSelector::getRegClass(LLT Ty, const RegisterBank &RB) const {
  if (RB.getID() == Z80::GPRRegBankID) {
    if (Ty.getSizeInBits() <= 8)
      return &Z80::R8RegClass;
    if (Ty.getSizeInBits() == 16)
      return &Z80::R16RegClass;
    if (Ty.getSizeInBits() == 24)
      return &Z80::R24RegClass;
  }

  llvm_unreachable("Unknown RegBank!");
}

const TargetRegisterClass *
Z80InstructionSelector::getRegClass(LLT Ty, unsigned Reg,
                                    MachineRegisterInfo &MRI) const {
  const RegisterBank &RegBank = *RBI.getRegBank(Reg, MRI, TRI);
  return getRegClass(Ty, RegBank);
}

static int64_t getSubRegIndex(unsigned Width, unsigned Off = 0) {
  switch (Width) {
  case 8:
    switch (Off) {
    case 0: return Z80::sub_low;
    case 8: return Z80::sub_high;
    }
    break;
  case 16:
    switch (Off) {
    case 0: return Z80::sub_short;
    }
    break;
  }
  return Z80::NoSubRegister;
}

static const TargetRegisterClass *getRegClassFromGRPhysReg(Register Reg) {
  assert(Reg.isPhysical());
  for (auto *RC : {&Z80::R8RegClass, &Z80::F8RegClass, &Z80::R16RegClass,
                   &Z80::Z16RegClass, &Z80::R24RegClass, &Z80::Z24RegClass})
    if (RC->contains(Reg))
      return RC;
  llvm_unreachable("Unknown RegClass for PhysReg!");
}

// Set Z80 Opcode and constrain DstReg.
bool Z80InstructionSelector::selectCopy(MachineInstr &I,
                                        MachineRegisterInfo &MRI) const {
  Register DstReg = I.getOperand(0).getReg();
  unsigned DstSize = RBI.getSizeInBits(DstReg, MRI, TRI);
  if (DstSize == 1)
    DstSize = 8;
  const RegisterBank &DstRegBank = *RBI.getRegBank(DstReg, MRI, TRI);

  Register SrcReg = I.getOperand(1).getReg();
  unsigned SrcSize = RBI.getSizeInBits(SrcReg, MRI, TRI);
  if (SrcSize == 1)
    SrcSize = 8;
  const RegisterBank &SrcRegBank = *RBI.getRegBank(SrcReg, MRI, TRI);

  if (DstReg.isPhysical()) {
    assert(I.isCopy() && "Generic operators do not allow physical registers");

    if (DstReg == Z80::F &&
        !RBI.constrainGenericRegister(SrcReg, Z80::F8RegClass, MRI))
      return false;

    if (DstSize > SrcSize && SrcRegBank.getID() == Z80::GPRRegBankID &&
        DstRegBank.getID() == Z80::GPRRegBankID) {

      if (SrcSize != DstSize) {
        // This case can be generated by ABI lowering, perform anyext
        MachineIRBuilder MIB(I);
        I.getOperand(1).setReg(
            MIB.buildInstr(
                   TargetOpcode::INSERT_SUBREG, {DstRC},
                   {MIB.buildInstr(TargetOpcode::IMPLICIT_DEF, {DstRC}, {}),
                    SrcReg, getSubRegIndex(SrcSize)})
                .getReg(0));
      }
    }

    return true;
  }

  assert((!SrcReg.isPhysical() || I.isCopy()) &&
         "No phys reg on generic operators");
  assert((DstSize == SrcSize ||
          // Copies are a means to setup initial types, the number of
          // bits may not exactly match.
          (SrcReg.isPhysical() &&
           DstSize <= RBI.getSizeInBits(SrcReg, MRI, TRI))) &&
         "Copy with different width?!");

  const TargetRegisterClass *DstRC = MRI.getRegClassOrNull(DstReg);
  if (!DstRC)
    DstRC = getRegClass(MRI.getType(DstReg), DstRegBank);

  if (SrcRegBank.getID() == Z80::GPRRegBankID &&
      DstRegBank.getID() == Z80::GPRRegBankID && SrcSize > DstSize &&
      SrcReg.isPhysical()) {
    // Change the physical register to perform truncate.

    const TargetRegisterClass *SrcRC = getRegClassFromGRPhysReg(SrcReg);

    if (DstRC != SrcRC) {
      I.getOperand(1).setSubReg(getSubRegIndex(TRI.getRegSizeInBits(*DstRC)));
      I.getOperand(1).substPhysReg(SrcReg, TRI);
    }
  }

  // No need to constrain SrcReg. It will get constrained when
  // we hit another of its use or its defs.
  // Copies do not have constraints.
  const TargetRegisterClass *OldRC = MRI.getRegClassOrNull(DstReg);
  if (!OldRC || !DstRC->hasSubClassEq(OldRC)) {
    if (!RBI.constrainGenericRegister(DstReg, *DstRC, MRI)) {
      LLVM_DEBUG(dbgs() << "Failed to constrain " << TII.getName(I.getOpcode())
                        << " operand\n");
      return false;
    }
  }
  I.setDesc(TII.get(Z80::COPY));
  return true;
}

bool Z80InstructionSelector::select(MachineInstr &I) const {
  assert(I.getParent() && "Instruction should be in a basic block!");
  assert(I.getParent()->getParent() && "Instruction should be in a function!");

  MachineBasicBlock &MBB = *I.getParent();
  MachineFunction &MF = *MBB.getParent();
  MachineRegisterInfo &MRI = MF.getRegInfo();

  unsigned Opc = I.getOpcode();
  if (!isPreISelGenericOpcode(Opc)) {
    switch (I.getOpcode()) {
    case TargetOpcode::COPY:
      return selectCopy(I, MRI);
    case Z80::SetCC:
      return selectSetCond(I, MRI);
    }
    return true;
  }

  assert(I.getNumOperands() == I.getNumExplicitOperands() &&
         "Generic instruction has unexpected implicit operands");

  if (selectImpl(I, *CoverageInfo))
    return true;

  LLVM_DEBUG(dbgs() << " C++ instruction selection: "; I.print(dbgs()));

  // TODO: This should be implemented by tblgen.
  switch (I.getOpcode()) {
  case TargetOpcode::G_CONSTANT:
  case TargetOpcode::G_GLOBAL_VALUE:
  case TargetOpcode::G_JUMP_TABLE:
    return selectConstant(I, MRI);
  case TargetOpcode::G_TRUNC:
    return selectTrunc(I, MRI);
  case TargetOpcode::G_PTRTOINT:
  case TargetOpcode::G_INTTOPTR:
  case TargetOpcode::G_FREEZE:
    return selectCopy(I, MRI);
  case TargetOpcode::G_SEXT:
    return selectSExt(I, MRI);
  case TargetOpcode::G_ZEXT:
    return selectZExt(I, MRI);
  case TargetOpcode::G_ANYEXT:
    return selectAnyExt(I, MRI);
  case TargetOpcode::G_LOAD:
  case TargetOpcode::G_STORE:
    return selectLoadStore(I, MRI, MF);
  case TargetOpcode::G_PTR_ADD:
  case TargetOpcode::G_FRAME_INDEX:
    return selectFrameIndexOrGep(I, MRI, MF);
  case TargetOpcode::G_UNMERGE_VALUES:
    return selectUnmergeValues(I, MRI, MF);
  case TargetOpcode::G_MERGE_VALUES:
    return selectMergeValues(I, MRI, MF);
  case TargetOpcode::G_SELECT:
    return selectSelect(I, MRI);
  case TargetOpcode::G_SHL:
  case TargetOpcode::G_LSHR:
  case TargetOpcode::G_ASHR:
    return selectShift(I, MRI);
  case TargetOpcode::G_FSHL:
  case TargetOpcode::G_FSHR:
    return selectFunnelShift(I, MRI);
  case TargetOpcode::G_UADDO:
  case TargetOpcode::G_UADDE:
  case TargetOpcode::G_USUBO:
  case TargetOpcode::G_USUBE:
  case TargetOpcode::G_SADDO:
  case TargetOpcode::G_SADDE:
  case TargetOpcode::G_SSUBO:
  case TargetOpcode::G_SSUBE:
  case TargetOpcode::G_ICMP:
    return selectSetCond(I, MRI);
  case TargetOpcode::G_BRCOND:
    return selectBrCond(I, MRI);
  case TargetOpcode::G_BRINDIRECT:
    I.setDesc(TII.get(STI.is24Bit() ? Z80::JP24r : Z80::JP16r));
    return constrainSelectedInstRegOperands(I, TII, TRI, RBI);
  case TargetOpcode::G_BRJT:
    return selectBrJT(I, MRI, MF);
  case TargetOpcode::G_IMPLICIT_DEF:
  case TargetOpcode::G_PHI:
    return selectImplicitDefOrPHI(I, MRI);
  default:
    return false;
  }
}

bool Z80InstructionSelector::selectConstant(MachineInstr &I,
                                            MachineRegisterInfo &MRI) const {
  assert((I.getOpcode() == TargetOpcode::G_CONSTANT ||
          I.getOpcode() == TargetOpcode::G_GLOBAL_VALUE ||
          I.getOpcode() == TargetOpcode::G_JUMP_TABLE) &&
         "unexpected instruction");

  const Register DefReg = I.getOperand(0).getReg();
  LLT Ty = MRI.getType(DefReg);

  unsigned NewOpc;
  switch (Ty.getSizeInBits()) {
  case 8:
    NewOpc = Z80::LD8ri;
    break;
  case 16:
    NewOpc = Z80::LD16ri;
    break;
  case 24:
    assert(STI.is24Bit() && "Illegal operand size.");
    NewOpc = Z80::LD24ri;
    break;
  default:
    llvm_unreachable("Unsupported type.");
  }

  I.setDesc(TII.get(NewOpc));
  return constrainSelectedInstRegOperands(I, TII, TRI, RBI);
}

bool Z80InstructionSelector::selectTrunc(MachineInstr &I,
                                         MachineRegisterInfo &MRI) const {
  assert((I.getOpcode() == TargetOpcode::G_TRUNC) && "unexpected instruction");

  const Register DstReg = I.getOperand(0).getReg();
  const Register SrcReg = I.getOperand(1).getReg();

  const LLT DstTy = MRI.getType(DstReg);
  const LLT SrcTy = MRI.getType(SrcReg);

  const RegisterBank &DstRB = *RBI.getRegBank(DstReg, MRI, TRI);
  const RegisterBank &SrcRB = *RBI.getRegBank(SrcReg, MRI, TRI);

  const TargetRegisterClass *DstRC = getRegClass(DstTy, DstRB);
  const TargetRegisterClass *SrcRC = getRegClass(SrcTy, SrcRB);

  if (!DstRC || !SrcRC)
    return false;

  unsigned SubIdx = Z80::NoSubRegister;
  if (TRI.getRegSizeInBits(*DstRC) < TRI.getRegSizeInBits(*SrcRC)) {
    SubIdx = getSubRegIndex(TRI.getRegSizeInBits(*DstRC));
    SrcRC = TRI.getSubClassWithSubReg(SrcRC, SubIdx);
  }

  if (!RBI.constrainGenericRegister(SrcReg, *SrcRC, MRI) ||
      !RBI.constrainGenericRegister(DstReg, *DstRC, MRI)) {
    LLVM_DEBUG(dbgs() << "Failed to constrain " << TII.getName(I.getOpcode())
                      << "\n");
    return false;
  }

  I.getOperand(1).setSubReg(SubIdx);

  I.setDesc(TII.get(Z80::COPY));
  return true;
}

bool Z80InstructionSelector::selectSExt(MachineInstr &I,
                                        MachineRegisterInfo &MRI) const {
  assert((I.getOpcode() == TargetOpcode::G_SEXT) && "unexpected instruction");

  const Register DstReg = I.getOperand(0).getReg();
  const Register SrcReg = I.getOperand(1).getReg();

  const LLT DstTy = MRI.getType(DstReg);
  const LLT SrcTy = MRI.getType(SrcReg);

  if (SrcTy != LLT::scalar(1))
    return false;

  MachineIRBuilder MIB(I);

  unsigned FillOpc;
  Register FillReg;
  const TargetRegisterClass *FillRC;
  switch (DstTy.getSizeInBits()) {
  case 8:
    FillOpc = Z80::SBC8ar;
    FillReg = Z80::A;
    FillRC = &Z80::R8RegClass;
    break;
  case 16:
    FillOpc = Z80::SBC16aa;
    FillReg = Z80::HL;
    FillRC = &Z80::R16RegClass;
    break;
  case 24:
    FillOpc = Z80::SBC24aa;
    FillReg = Z80::UHL;
    FillRC = &Z80::R24RegClass;
    break;
  default:
    return false;
  }

  auto Rotate = MIB.buildInstr(Z80::RRC8r, {LLT::scalar(8)}, {SrcReg});
  if (!constrainSelectedInstRegOperands(*Rotate, TII, TRI, RBI))
    return false;
  auto Fill = MIB.buildInstr(FillOpc);
  Fill->findRegisterUseOperand(FillReg)->setIsUndef();
  if (FillOpc == Z80::SBC8ar)
    Fill.addReg(FillReg, RegState::Undef);
  if (!constrainSelectedInstRegOperands(*Fill, TII, TRI, RBI))
    return false;
  auto CopyFromReg = MIB.buildCopy(DstReg, FillReg);
  if (!RBI.constrainGenericRegister(CopyFromReg.getReg(0), *FillRC, MRI))
    return false;

  I.eraseFromParent();
  return true;
}

bool Z80InstructionSelector::selectZExt(MachineInstr &I,
                                        MachineRegisterInfo &MRI) const {
  assert((I.getOpcode() == TargetOpcode::G_ZEXT) && "unexpected instruction");

  Register DstReg = I.getOperand(0).getReg();
  Register SrcReg = I.getOperand(1).getReg();

  if (MRI.getType(SrcReg) != LLT::scalar(1))
    return false;

  MachineIRBuilder MIB(I);

  auto CopyToA = MIB.buildCopy(Z80::A, SrcReg);
  if (!constrainSelectedInstRegOperands(*CopyToA, TII, TRI, RBI))
    return false;
  auto And = MIB.buildInstr(Z80::AND8ai, {}, {int64_t(1)});
  if (!constrainSelectedInstRegOperands(*And, TII, TRI, RBI))
    return false;

  auto CopyFromA = MIB.buildCopy(LLT::scalar(8), Register(Z80::A));
  if (!RBI.constrainGenericRegister(CopyFromA.getReg(0), Z80::R8RegClass, MRI))
    return false;

  auto ZExt = MIB.buildZExtOrTrunc(DstReg, CopyFromA);

  I.eraseFromParent();
  return select(*ZExt);
}

bool Z80InstructionSelector::selectAnyExt(MachineInstr &I,
                                          MachineRegisterInfo &MRI) const {
  assert((I.getOpcode() == TargetOpcode::G_ANYEXT) && "unexpected instruction");

  const Register DstReg = I.getOperand(0).getReg();
  const TargetRegisterClass *DstRC = getRegClass(DstReg, MRI);
  const unsigned DstSize = RBI.getSizeInBits(DstReg, MRI, TRI);

  const Register SrcReg = I.getOperand(1).getReg();
  const TargetRegisterClass *SrcRC = getRegClass(SrcReg, MRI);
  unsigned SrcSize = RBI.getSizeInBits(SrcReg, MRI, TRI);

  const LLT DstTy = MRI.getType(DstReg);
  const LLT SrcTy = MRI.getType(SrcReg);

  const RegisterBank &DstRB = *RBI.getRegBank(DstReg, MRI, TRI);
  const RegisterBank &SrcRB = *RBI.getRegBank(SrcReg, MRI, TRI);

  assert(DstRB.getID() == SrcRB.getID() &&
         "G_ANYEXT input/output on different banks\n");

  assert(DstSize > SrcSize && "G_ANYEXT incorrect operand size");
  if (SrcSize == 1)
    SrcSize = 8;
  assert(DstSize >= SrcSize && "G_ANYEXT incorrect operand size");

  const TargetRegisterClass *DstRC = getRegClass(DstTy, DstRB);
  const TargetRegisterClass *SrcRC = getRegClass(SrcTy, SrcRB);

  if (!RBI.constrainGenericRegister(SrcReg, *SrcRC, MRI) ||
      !RBI.constrainGenericRegister(DstReg, *DstRC, MRI)) {
    LLVM_DEBUG(dbgs() << "Failed to constrain " << TII.getName(I.getOpcode())
                      << " operand\n");
    return false;
  }

  if (DstSize == SrcSize) {
    I.setDesc(TII.get(Z80::COPY));
    return true;
  }

  MachineIRBuilder MIB(I);
  MIB.buildInstr(TargetOpcode::INSERT_SUBREG, {DstReg},
                 {MIB.buildInstr(TargetOpcode::IMPLICIT_DEF, {DstRC}, {}),
                  SrcReg, getSubRegIndex(SrcSize)});
  I.eraseFromParent();
  return true;
}

static bool canFoldLoad(MachineInstr &LoadMI, MachineInstr &TargetMI,
                        MachineRegisterInfo &MRI, bool Ordered = false) {
  assert(LoadMI.mayLoad() && "Expected a load");
  auto *MBB = LoadMI.getParent();
  if (!MBB || TargetMI.getParent() != MBB)
    return false;
  if (Ordered)
    for (auto *MI : {&LoadMI, &TargetMI})
      if (!MRI.hasOneUse(MI->getOperand(0).getReg()))
          return false;
  for (MachineBasicBlock::iterator I(LoadMI), E(MBB->end()); ++I != E;) {
    if (I->isLoadFoldBarrier())
      return false;
    if (Ordered)
      for (auto *MMO : I->memoperands())
        if (!MMO->isUnordered())
          return false;
    if (I == TargetMI)
      return true;
  }
  return false;
}

bool Z80InstructionSelector::selectLoadStore(MachineInstr &I,
                                             MachineRegisterInfo &MRI,
                                             MachineFunction &MF) const {
  bool IsLoad = I.getOpcode() == TargetOpcode::G_LOAD;
  assert((IsLoad || I.getOpcode() == TargetOpcode::G_STORE) &&
         "unexpected instruction");

  Register ValReg = I.getOperand(0).getReg();
  Register PtrReg = I.getOperand(1).getReg();
  MachineInstr *PtrMI = MRI.getVRegDef(PtrReg);
  LLT Ty = MRI.getType(ValReg);

  bool RMWOrdered = false;
  SmallVector<unsigned, 3> RMWOps;
  SmallVector<MachineInstr *, 2> MemMOs;
  MemMOs.push_back(&I);
  MachineInstr *ValMI = MRI.getVRegDef(ValReg);
  if (!IsLoad && Ty == LLT::scalar(8) && ValMI) {
    unsigned ValLastOpIdx = ValMI->getNumExplicitOperands() - 1;
    if (std::next(MachineBasicBlock::iterator(ValMI)) == I &&
        ValMI->getNumDefs() == 1 && ValLastOpIdx >= 2) {
      Register LoadReg = ValMI->getOperand(1).getReg();
      if (MachineInstr *LoadMI = MRI.getVRegDef(LoadReg)) {
        for (MachineInstr *MemMI : {&I, LoadMI})
          for (MachineMemOperand *MMO : MemMI->memoperands())
            if (!MMO->isUnordered())
              RMWOrdered = true;
        if (LoadMI->getOpcode() == TargetOpcode::G_LOAD &&
            LoadMI->getOperand(1).getReg() == PtrReg &&
            canFoldLoad(*LoadMI, *ValMI, MRI, RMWOrdered)) {
          assert(LoadMI->hasOneMemOperand() &&
                 "Expected load to have one MMO.");
          MemMOs.push_back(LoadMI);
          Register ImmReg = ValMI->getOperand(ValLastOpIdx).getReg();
          if (auto OffConst = getConstantVRegVal(ImmReg, MRI)) {
            switch (ValMI->getOpcode()) {
            case TargetOpcode::G_FSHL:
              if (ValMI->getOperand(2).getReg() != LoadReg)
                break;
              if (*OffConst == 1)
                RMWOps = {Z80::RLC8p, Z80::RLC8o};
              else if (*OffConst == 7)
                RMWOps = {Z80::RRC8p, Z80::RRC8o};
              break;
            case TargetOpcode::G_FSHR:
              if (ValMI->getOperand(2).getReg() != LoadReg)
                break;
              if (*OffConst == 1)
                RMWOps = {Z80::RLC8p, Z80::RLC8o};
              else if (*OffConst == 7)
                RMWOps = {Z80::RRC8p, Z80::RRC8o};
              break;
            case TargetOpcode::G_SHL:
              if (*OffConst == 1)
                RMWOps = {Z80::SLA8p, Z80::SLA8o};
              break;
            case TargetOpcode::G_ASHR:
              if (*OffConst == 1)
                RMWOps = {Z80::SRA8p, Z80::SRA8o};
              break;
            case TargetOpcode::G_LSHR:
              if (*OffConst == 1)
                RMWOps = {Z80::SRL8p, Z80::SRL8o};
              break;
            case TargetOpcode::G_AND:
              if (isPowerOf2_32(~*OffConst & 0xFF))
                RMWOps = {Z80::RES8bp, Z80::RES8bo, Log2_32(~*OffConst & 0xFF)};
              break;
            case TargetOpcode::G_OR:
              if (isPowerOf2_32(*OffConst & 0xFF))
                RMWOps = {Z80::SET8bp, Z80::SET8bo, Log2_32(*OffConst & 0xFF)};
              break;
            case TargetOpcode::G_ADD:
              if (*OffConst == 1)
                RMWOps = {Z80::INC8p, Z80::INC8o};
              else if (*OffConst == -1)
                RMWOps = {Z80::DEC8p, Z80::DEC8o};
              break;
            }
          }
        }
      }
    }
  }

  I.RemoveOperand(1);
  I.RemoveOperand(0);
  MachineInstrBuilder MIB(MF, I);
  SmallVector<MachineOperand, 2> MOs;
  int32_t Off = 0;
  while (PtrMI) {
    switch (PtrMI->getOpcode()) {
    case TargetOpcode::G_INTTOPTR:
      if (MachineInstr *IntMI = MRI.getVRegDef(PtrMI->getOperand(1).getReg()))
        if (IntMI->getOpcode() == TargetOpcode::G_CONSTANT)
          MOs.push_back(MachineOperand::CreateImm(
              IntMI->getOperand(1).getCImm()->getSExtValue() + Off));
      break;
    case TargetOpcode::G_GLOBAL_VALUE:
      MOs.push_back(PtrMI->getOperand(1));
      MOs.back().setOffset(MOs.back().getOffset() + Off);
      break;
    case TargetOpcode::G_FRAME_INDEX:
      MOs.push_back(PtrMI->getOperand(1));
      MOs.push_back(MachineOperand::CreateImm(Off));
      break;
    case TargetOpcode::G_PTR_ADD:
      if (auto OffConst =
              getConstantVRegVal(PtrMI->getOperand(2).getReg(), MRI)) {
        if ((PtrMI = MRI.getVRegDef(PtrMI->getOperand(1).getReg()))) {
          Off += *OffConst;
          continue;
        }
      }
      break;
    }
    break;
  }

  unsigned Opc;
  if (MOs.size() == 1 && (MOs[0].isImm() || MOs[0].isGlobal())) {
    if (RMWOps.empty()) {
      switch (Ty.getSizeInBits()) {
      case 8: {
        MachineIRBuilder Builder(I);
        MachineInstrBuilder CopyI;
        if (IsLoad) {
          Builder.setInsertPt(Builder.getMBB(),
                              std::next(Builder.getInsertPt()));
          CopyI = Builder.buildCopy(ValReg, Register(Z80::A));
          Opc = Z80::LD8am;
        } else {
          CopyI = Builder.buildCopy(Register(Z80::A), ValReg);
          Opc = Z80::LD8ma;
        }
        I.setDesc(TII.get(Opc));
        MIB.add(MOs[0]);
        MIB.addReg(Z80::A, getDefRegState(IsLoad) | RegState::Implicit);
        return RBI.constrainGenericRegister(ValReg, Z80::R8RegClass, MRI) &&
               constrainSelectedInstRegOperands(I, TII, TRI, RBI);
      }
      case 16:
        if (STI.is24Bit())
          break;
        I.setDesc(TII.get(IsLoad ? Z80::LD16rm : Z80::LD16mr));
        if (IsLoad)
          MIB.addDef(ValReg);
        MIB.add(MOs[0]);
        if (!IsLoad)
          MIB.addReg(ValReg);
        return constrainSelectedInstRegOperands(I, TII, TRI, RBI);
      case 24:
        assert(STI.is24Bit() && "Illegal memory access size.");
        I.setDesc(TII.get(IsLoad ? Z80::LD24rm : Z80::LD24mr));
        if (IsLoad)
          MIB.addDef(ValReg);
        MIB.add(MOs[0]);
        if (!IsLoad)
          MIB.addReg(ValReg);
        return constrainSelectedInstRegOperands(I, TII, TRI, RBI);
      }
    }
    MOs.clear();
    Off = 0;
  }

  if (MOs.empty()) {
    if (Off && isInt<8>(Off)) {
      MOs.push_back(
          MachineOperand::CreateReg(PtrMI->getOperand(0).getReg(), false));
      MOs.push_back(MachineOperand::CreateImm(Off));
    } else
      MOs.push_back(MachineOperand::CreateReg(PtrReg, false));
  }
  bool IsOff = MOs.size() == 2;
  if (RMWOps.empty()) {
    Optional<int64_t> ValConst;
    switch (Ty.getSizeInBits()) {
    case 8:
      if (!IsLoad)
        ValConst = getConstantVRegVal(ValReg, MRI);
      Opc = IsOff ? IsLoad ? Z80::LD8go : ValConst ? Z80::LD8oi : Z80::LD8og
                  : IsLoad ? Z80::LD8gp : ValConst ? Z80::LD8pi : Z80::LD8pg;
      break;
    case 16:
      Opc = STI.has16BitEZ80Ops() ? IsOff ? IsLoad ? Z80::LD16ro : Z80::LD16or
                                          : IsLoad ? Z80::LD16rp : Z80::LD16pr
                                  : IsOff ? IsLoad ? Z80::LD88ro : Z80::LD88or
                                          : IsLoad ? Z80::LD88rp : Z80::LD88pr;
      break;
    case 24:
      assert(STI.is24Bit() && "Illegal memory access size.");
      Opc = IsOff ? IsLoad ? Z80::LD24ro : Z80::LD24or
                  : IsLoad ? Z80::LD24rp : Z80::LD24pr;
      break;
    default:
      return false;
    }
    I.setDesc(TII.get(Opc));
    if (IsLoad)
      MIB.addDef(ValReg);
    for (auto &MO : MOs)
      MIB.add(MO);
    if (!IsLoad) {
      if (ValConst)
        MIB.addImm(*ValConst);
      else {
        MIB.addReg(ValReg);
        if (IsOff && Ty.getSizeInBits() > 8) {
          // Special handling for LD16/24or as explained in Z80InstrInfo.td.
          auto &MO = I.getOperand(2);
          ValReg = constrainOperandRegClass(MF, TRI, MRI, TII, RBI, I,
                                            *selectGRegClass(ValReg, MRI), MO);
          MO.setReg(ValReg);
        }
      }
    }
  } else {
    assert(Ty == LLT::scalar(8) && "Expected RMW operation to be 8 bits");
    I.setDesc(TII.get(RMWOps[IsOff]));
    if (RMWOps.size() > 2)
      MIB.addImm(RMWOps[2]);
    for (auto &MO : MOs)
      MIB.add(MO);
    I.addImplicitDefUseOperands(MF);
    MIB.cloneMergedMemRefs(MemMOs);
    if (!MRI.use_empty(ValReg)) {
      assert(!RMWOrdered && "Value of ordered RMW operation has too many uses");
      MachineIRBuilder MIB(I);
      MIB.setInsertPt(MIB.getMBB(), ++MIB.getInsertPt());
      auto Reload =
          MIB.buildInstr(IsOff ? Z80::LD8go : Z80::LD8gp, {ValReg}, {});
      for (auto &MO : MOs)
        Reload.add(MO);
      Reload.cloneMemRefs(I);
      if (!constrainSelectedInstRegOperands(*Reload, TII, TRI, RBI))
        return false;
      ValMI->getOperand(0).setReg(MRI.cloneVirtualRegister(ValReg));
    } else if (RMWOrdered) {
      MachineInstr &LoadMI = *MemMOs[1];
      LoadMI.setDesc(TII.get(TargetOpcode::IMPLICIT_DEF));
      while (LoadMI.getNumOperands() > 1)
        LoadMI.RemoveOperand(1);
      LoadMI.dropMemRefs(MF);
    }
  }

  return constrainSelectedInstRegOperands(I, TII, TRI, RBI);
}

bool Z80InstructionSelector::selectFrameIndexOrGep(MachineInstr &I,
                                                   MachineRegisterInfo &MRI,
                                                   MachineFunction &MF) const {
  bool Is24Bit = STI.is24Bit();
  bool HasLEA = STI.hasEZ80Ops();
  unsigned Opc = I.getOpcode();
  assert(
      (Opc == TargetOpcode::G_FRAME_INDEX || Opc == TargetOpcode::G_PTR_ADD) &&
      "unexpected instruction");

  if (Opc == TargetOpcode::G_PTR_ADD) {
    auto Off = getConstantVRegVal(I.getOperand(2).getReg(), MRI);
    if (Off && *Off >= -1 && *Off <= 1) {
      I.RemoveOperand(2);
      if (!*Off) {
        I.setDesc(TII.get(TargetOpcode::COPY));
        return selectCopy(I, MRI);
      }
      I.setDesc(TII.get(*Off == 1 ? Is24Bit ? Z80::INC24r : Z80::INC16r
                                  : Is24Bit ? Z80::DEC24r : Z80::DEC16r));
      return constrainSelectedInstRegOperands(I, TII, TRI, RBI);
    }
    if (!HasLEA || !Off || !isInt<8>(*Off)) {
      I.setDesc(TII.get(Is24Bit ? Z80::ADD24ao : Z80::ADD16ao));
      return constrainSelectedInstRegOperands(I, TII, TRI, RBI);
    }
    I.getOperand(2).ChangeToImmediate(*Off);
  }

  // Use LEA to calculate frame index and GEP
  I.setDesc(TII.get(Is24Bit ? Z80::LEA24ro : Z80::LEA16ro));

  // Make a note if this LEA is illegal.
  if (!HasLEA)
    MF.getInfo<Z80MachineFunctionInfo>()->setHasIllegalLEA();

  if (Opc == TargetOpcode::G_FRAME_INDEX)
    MachineInstrBuilder(MF, I).addImm(0);

  return constrainSelectedInstRegOperands(I, TII, TRI, RBI);
}

bool Z80InstructionSelector::selectUnmergeValues(MachineInstr &I,
                                                 MachineRegisterInfo &MRI,
                                                 MachineFunction &MF) const {
  assert((I.getOpcode() == TargetOpcode::G_UNMERGE_VALUES) &&
         "unexpected instruction");
  MachineIRBuilder MIB(I);
  Register LoReg = I.getOperand(0).getReg();
  Register HiReg = I.getOperand(1).getReg();
  Register SrcReg = I.getOperand(I.getNumOperands() - 1).getReg();
  LLT Ty = MRI.getType(SrcReg);
  assert(MRI.getType(LoReg) == LLT::scalar(8) &&
         MRI.getType(HiReg) == LLT::scalar(8) && Ty.isScalar() &&
         "Illegal type");
  const TargetRegisterClass *RC;
  switch (Ty.getSizeInBits()) {
  case 16:
    assert(I.getNumOperands() == 3 && "Illegal instruction");
    RC = STI.hasIndexHalfRegs() ? &Z80::R16RegClass : &Z80::G16RegClass;
    MIB.buildInstr(TargetOpcode::COPY, {LoReg}, {})
        .addReg(SrcReg, 0, Z80::sub_low);
    MIB.buildInstr(TargetOpcode::COPY, {HiReg}, {})
        .addReg(SrcReg, 0, Z80::sub_high);
    break;
  case 24: {
    Register UpReg = I.getOperand(2).getReg();
    assert(STI.is24Bit() && I.getNumOperands() == 4 &&
           MRI.getType(UpReg) == LLT::scalar(8) && "Illegal instruction");
    RC = &Z80::R24RegClass;
    int FI = MF.getFrameInfo().CreateStackObject(3, Align(1), false);
    MIB.buildInstr(Z80::LD24or).addFrameIndex(FI).addImm(0).addReg(SrcReg);
    MIB.buildInstr(Z80::LD8ro, {UpReg}, {}).addFrameIndex(FI).addImm(2);
    MIB.buildInstr(TargetOpcode::COPY, {HiReg}, {})
        .addReg(SrcReg, 0, Z80::sub_high);
    MIB.buildInstr(TargetOpcode::COPY, {LoReg}, {})
        .addReg(SrcReg, 0, Z80::sub_low);
    if (!RBI.constrainGenericRegister(UpReg, Z80::R8RegClass, MRI))
      return false;
    break;
  }
  default:
    llvm_unreachable("Illegal instruction");
  }
  I.eraseFromParent();
  return RBI.constrainGenericRegister(LoReg, Z80::R8RegClass, MRI) &&
         RBI.constrainGenericRegister(HiReg, Z80::R8RegClass, MRI) &&
         RBI.constrainGenericRegister(SrcReg, *RC, MRI);
}

bool Z80InstructionSelector::selectMergeValues(MachineInstr &I,
                                               MachineRegisterInfo &MRI,
                                               MachineFunction &MF) const {
  assert((I.getOpcode() == TargetOpcode::G_MERGE_VALUES) &&
         "unexpected instruction");
  MachineIRBuilder MIB(I);
  Register DstReg = I.getOperand(0).getReg();
  const TargetRegisterClass *RC;
  switch (MRI.getType(DstReg).getSizeInBits()) {
  case 16: {
    assert(I.getNumOperands() == 3 &&
           MRI.getType(I.getOperand(1).getReg()) == LLT::scalar(8) &&
           MRI.getType(I.getOperand(2).getReg()) == LLT::scalar(8) &&
           "Illegal instruction");
    RC = STI.hasIndexHalfRegs() ? &Z80::R16RegClass : &Z80::G16RegClass;
    auto SeqI = MIB.buildInstr(TargetOpcode::REG_SEQUENCE, {DstReg},
                               {I.getOperand(1), int64_t(Z80::sub_low),
                                I.getOperand(2), int64_t(Z80::sub_high)});
    if (!constrainSelectedInstRegOperands(*SeqI, TII, TRI, RBI))
      return false;
    break;
  }
  case 24: {
    assert(STI.is24Bit() && "Illegal memory access size.");
    assert(I.getNumOperands() == 4 &&
           MRI.getType(I.getOperand(1).getReg()) == LLT::scalar(8) &&
           MRI.getType(I.getOperand(2).getReg()) == LLT::scalar(8) &&
           MRI.getType(I.getOperand(3).getReg()) == LLT::scalar(8) &&
           "Illegal instruction");
    RC = &Z80::R24RegClass;
    Register UpReg = I.getOperand(3).getReg(), TmpReg;
    unsigned Amt;
    if (mi_match(UpReg, MRI, m_GAShr(m_Reg(TmpReg), m_ICst(Amt))) &&
        Amt == 7) {
      auto AddI = MIB.buildInstr(Z80::RLC8r, {LLT::scalar(8)}, {TmpReg});
      auto SbcI = MIB.buildInstr(Z80::SBC24aa);
      SbcI->findRegisterUseOperand(Z80::UHL)->setIsUndef();
      TmpReg = MIB.buildCopy(RC, Register(Z80::UHL)).getReg(0);
      if (!constrainSelectedInstRegOperands(*AddI, TII, TRI, RBI) ||
          !constrainSelectedInstRegOperands(*SbcI, TII, TRI, RBI))
        return false;
    } else {
      UpReg = {};
      int FI = MF.getFrameInfo().CreateStackObject(1, Align(1), false);
      auto Store = MIB.buildInstr(Z80::LD8or).addFrameIndex(FI).addImm(0)
                       .add(I.getOperand(3));
      if (!constrainSelectedInstRegOperands(*Store, TII, TRI, RBI))
        return false;
      TmpReg = MIB.buildInstr(Z80::LD24ro, {RC}, {})
                   .addFrameIndex(FI).addImm(-2).getReg(0);
    }
    if (I.getOperand(2).getReg() != UpReg) {
      auto InsertI =
          MIB.buildInstr(Z80::INSERT_SUBREG, {RC},
                         {TmpReg, I.getOperand(2), int64_t(Z80::sub_high)});
      if (!constrainSelectedInstRegOperands(*InsertI, TII, TRI, RBI))
        return false;
      TmpReg = InsertI.getReg(0);
    }
    if (I.getOperand(1).getReg() != UpReg) {
      auto InsertI =
          MIB.buildInstr(Z80::INSERT_SUBREG, {RC},
                         {TmpReg, I.getOperand(1), int64_t(Z80::sub_low)});
      if (!constrainSelectedInstRegOperands(*InsertI, TII, TRI, RBI))
        return false;
      TmpReg = InsertI.getReg(0);
    }
    MIB.buildCopy(DstReg, TmpReg);
    break;
  }
  default:
    llvm_unreachable("Illegal instruction");
  }
  I.eraseFromParent();
  return RBI.constrainGenericRegister(DstReg, *RC, MRI);
}

Z80::CondCode
Z80InstructionSelector::foldCompare(MachineInstr &I, MachineIRBuilder &MIB,
                                    MachineRegisterInfo &MRI) const {
  assert(I.getOpcode() == TargetOpcode::G_ICMP && "unexpected instruction");
  const Function &F = MIB.getMF().getFunction();
  bool OptSize = F.hasOptSize();

  auto Pred = CmpInst::Predicate(I.getOperand(1).getPredicate());
  Register LHSReg = I.getOperand(2).getReg();
  Register RHSReg = I.getOperand(3).getReg();
  LLT OpTy = MRI.getType(LHSReg);
  unsigned OpSize = OpTy.getSizeInBits();
  assert(MRI.getType(I.getOperand(0).getReg()) == LLT::scalar(1) &&
         !OpTy.isVector() && MRI.getType(RHSReg) == OpTy && "Unexpected type");

  bool IsSigned, IsSwapped, IsConst;
  Z80::CondCode CC =
      Z80::GetBranchConditionForPredicate(Pred, IsSigned, IsSwapped, IsConst);
  auto ConstRHS = getConstantVRegValWithLookThrough(RHSReg, MRI);
  if (IsSwapped) {
    if (ConstRHS && ConstRHS->Value != int64_t(IsSigned ? maxIntN(OpSize)
                                                        : maxUIntN(OpSize))) {
      ++ConstRHS->Value;
      CC = Z80::GetOppositeBranchCondition(CC);
    } else
      std::swap(LHSReg, RHSReg);
  }

  unsigned Opc, LDIOpc, AddOpc;
  Register Reg;
  switch (OpSize) {
  case 8:
    Opc = Z80::CP8ar;
    Reg = Z80::A;
    break;
  case 16:
    Opc = Z80::SUB16ao;
    LDIOpc = Z80::LD16ri;
    AddOpc = Z80::ADD16ao;
    Reg = Z80::HL;
    break;
  case 24:
    Opc = Z80::SUB24ao;
    LDIOpc = Z80::LD24ri;
    AddOpc = Z80::ADD24ao;
    Reg = Z80::UHL;
    break;
  default:
    return Z80::COND_INVALID;
  }

  if (IsSigned && !OptSize) {
    int64_t Sign = minIntN(OpSize);
    if (OpSize == 8) {
      if (ConstRHS)
        ConstRHS->Value += Sign;
      else {
        auto CopyRHSToA = MIB.buildCopy(Register(Z80::A), RHSReg);
        if (!constrainSelectedInstRegOperands(*CopyRHSToA, TII, TRI, RBI))
          return Z80::COND_INVALID;
        auto AddRHS = MIB.buildInstr(Z80::ADD8ai, {}, {Sign});
        if (!constrainSelectedInstRegOperands(*AddRHS, TII, TRI, RBI))
          return Z80::COND_INVALID;
        auto CopyRHSFromA = MIB.buildCopy(OpTy, Register(Z80::A));
        if (!constrainSelectedInstRegOperands(*CopyRHSFromA, TII, TRI, RBI))
          return Z80::COND_INVALID;
        RHSReg = CopyRHSFromA.getReg(0);
      }
      auto CopyLHSToA = MIB.buildCopy(Register(Z80::A), LHSReg);
      if (!constrainSelectedInstRegOperands(*CopyLHSToA, TII, TRI, RBI))
        return Z80::COND_INVALID;
      auto AddLHS = MIB.buildInstr(Z80::ADD8ai, {}, {Sign});
      if (!constrainSelectedInstRegOperands(*AddLHS, TII, TRI, RBI))
        return Z80::COND_INVALID;
      auto CopyLHSFromA = MIB.buildCopy(OpTy, Register(Z80::A));
      if (!constrainSelectedInstRegOperands(*CopyLHSFromA, TII, TRI, RBI))
        return Z80::COND_INVALID;
      LHSReg = CopyLHSFromA.getReg(0);
      if (!RBI.constrainGenericRegister(LHSReg, Z80::R8RegClass, MRI))
        return Z80::COND_INVALID;
    } else {
      auto LDI = MIB.buildInstr(LDIOpc, {OpTy}, {Sign});
      if (!constrainSelectedInstRegOperands(*LDI, TII, TRI, RBI))
        return Z80::COND_INVALID;
      if (ConstRHS)
        ConstRHS->Value += Sign;
      else {
        auto AddRHS = MIB.buildInstr(AddOpc, {OpTy}, {RHSReg, LDI});
        if (!constrainSelectedInstRegOperands(*AddRHS, TII, TRI, RBI))
          return Z80::COND_INVALID;
        RHSReg = AddRHS.getReg(0);
      }
      auto AddLHS = MIB.buildInstr(AddOpc, {OpTy}, {LHSReg, LDI});
      if (!constrainSelectedInstRegOperands(*AddLHS, TII, TRI, RBI))
        return Z80::COND_INVALID;
      LHSReg = AddLHS.getReg(0);
    }
    switch (CC) {
    default:
      llvm_unreachable("Expected signed condition");
    case Z80::COND_P:
      CC = Z80::COND_NC;
      break;
    case Z80::COND_M:
      CC = Z80::COND_C;
      break;
    }
  }

  SmallVector<SrcOp, 2> Ops = {RHSReg};
  if (ConstRHS) {
    if (!ConstRHS->Value && (CC == Z80::COND_Z || CC == Z80::COND_NZ)) {
      if (OpSize == 8) {
        Register SrcReg;
        uint8_t Mask;
        if (mi_match(LHSReg, MRI,
                     m_OneUse(m_GAnd(m_Reg(SrcReg), m_ICst(Mask)))) &&
            isPowerOf2_32(Mask)) {
          Opc = Z80::BIT8bg;
          Reg = {};
          Ops = {uint64_t(findFirstSet(Mask)), SrcReg};
        } else {
          Opc = Z80::OR8ar;
          Ops = {Reg};
        }
      } else {
        Opc = OpSize == 24 ? Z80::CP24a0 : Z80::CP16a0;
        Ops.clear();
      }
    } else if (OpSize == 8) {
      Opc = Z80::CP8ai;
      Ops = {ConstRHS->Value};
    } else {
      auto LDI = MIB.buildInstr(LDIOpc, {OpTy}, {ConstRHS->Value});
      if (!constrainSelectedInstRegOperands(*LDI, TII, TRI, RBI))
        return Z80::COND_INVALID;
      Ops = {LDI.getReg(0)};
    }
  }

  if (Reg.isValid()) {
    auto Copy = MIB.buildCopy(Reg, LHSReg);
    if (!constrainSelectedInstRegOperands(*Copy, TII, TRI, RBI))
      return Z80::COND_INVALID;
  }
  auto Cmp = MIB.buildInstr(Opc, {}, Ops);
  if (!constrainSelectedInstRegOperands(*Cmp, TII, TRI, RBI))
    return Z80::COND_INVALID;
  if (IsSigned && OptSize) {
    LLT s8 = LLT::scalar(8);
    Type *Int8Ty = Type::getInt8Ty(F.getContext());
    Register FlagsReg = MIB.buildCopy(s8, Register(Z80::F)).getReg(0);
    CallLowering::ArgInfo FlagsArg(FlagsReg, Int8Ty);
    Register SignedFlagsReg = MRI.createGenericVirtualRegister(s8);
    CallLowering::ArgInfo SignedFlagsArg(SignedFlagsReg, Int8Ty);
    createLibcall(MIB, RTLIB::SCMP, SignedFlagsArg, FlagsArg);
    MIB.buildCopy(Register(Z80::F), SignedFlagsReg);
    if (!RBI.constrainGenericRegister(FlagsReg, Z80::F8RegClass, MRI) ||
        !RBI.constrainGenericRegister(SignedFlagsReg, Z80::F8RegClass, MRI))
      return Z80::COND_INVALID;
  }
  return CC;
}

Z80::CondCode Z80InstructionSelector::foldExtendedAddSub(
    MachineInstr &I, MachineIRBuilder &MIB, MachineRegisterInfo &MRI) const {
  unsigned Opc = I.getOpcode();
  assert((Opc == TargetOpcode::G_UADDO || Opc == TargetOpcode::G_UADDE ||
          Opc == TargetOpcode::G_USUBO || Opc == TargetOpcode::G_USUBE ||
          Opc == TargetOpcode::G_SADDO || Opc == TargetOpcode::G_SADDE ||
          Opc == TargetOpcode::G_SSUBO || Opc == TargetOpcode::G_SSUBE) &&
         "unexpected instruction");

  bool IsAdd = Opc == TargetOpcode::G_UADDO || Opc == TargetOpcode::G_UADDE ||
               Opc == TargetOpcode::G_SADDO || Opc == TargetOpcode::G_SADDE;
  bool IsExtend = Opc == TargetOpcode::G_UADDE ||
                  Opc == TargetOpcode::G_USUBE ||
                  Opc == TargetOpcode::G_SADDE || Opc == TargetOpcode::G_SSUBE;
  bool IsSigned = Opc == TargetOpcode::G_SADDO ||
                  Opc == TargetOpcode::G_SADDE ||
                  Opc == TargetOpcode::G_SSUBO || Opc == TargetOpcode::G_SSUBE;

  Register DstReg = I.getOperand(0).getReg();
  Register LHSReg = I.getOperand(2).getReg();
  Register RHSReg = I.getOperand(3).getReg();
  LLT OpTy = MRI.getType(DstReg);

  unsigned AddSubOpc;
  Register AddSubReg;
  const TargetRegisterClass *AddSubRC;
  switch (OpTy.getSizeInBits()) {
  case 8:
    AddSubOpc = IsAdd ? Z80::ADC8ar : Z80::SBC8ar;
    AddSubReg = Z80::A;
    AddSubRC = &Z80::R8RegClass;
    break;
  case 16:
    AddSubOpc = IsAdd ? Z80::ADC16ao : Z80::SBC16ao;
    AddSubReg = Z80::HL;
    AddSubRC = &Z80::R16RegClass;
    break;
  case 24:
    AddSubOpc = IsAdd ? Z80::ADC24ao : Z80::SBC24ao;
    AddSubReg = Z80::UHL;
    AddSubRC = &Z80::R24RegClass;
    break;
  default:
    return Z80::COND_INVALID;
  }

  if (IsExtend) {
    Register CarryInReg = I.getOperand(4).getReg();
    Z80::CondCode CC = foldCond(CarryInReg, MIB, MRI);
    if (CC == Z80::COND_INVALID)
      return CC;
    if (CC != Z80::COND_C) {
      auto SetCC = MIB.buildInstr(Z80::SetCC, {LLT::scalar(1)}, {int64_t(CC)});
      if (!RBI.constrainGenericRegister(SetCC.getReg(0), Z80::R8RegClass, MRI))
        return Z80::COND_INVALID;
      auto BitI = MIB.buildInstr(Z80::RRC8r, {LLT::scalar(8)}, {SetCC});
      if (!constrainSelectedInstRegOperands(*BitI, TII, TRI, RBI))
        return Z80::COND_INVALID;
      if (!select(*SetCC))
        return Z80::COND_INVALID;
    }
  } else
    MIB.buildInstr(Z80::RCF);
  MIB.buildCopy(AddSubReg, LHSReg);
  if (!RBI.constrainGenericRegister(LHSReg, *AddSubRC, MRI))
    return Z80::COND_INVALID;
  auto AddSubI = MIB.buildInstr(AddSubOpc, {}, {RHSReg});
  if (!constrainSelectedInstRegOperands(*AddSubI, TII, TRI, RBI))
    return Z80::COND_INVALID;
  if (MIB.getInsertPt() == I) {
    MIB.buildCopy(DstReg, AddSubReg);
    if (!RBI.constrainGenericRegister(DstReg, *AddSubRC, MRI))
      return Z80::COND_INVALID;
  }
  return IsSigned ? Z80::COND_PE : Z80::COND_C;
}

Z80::CondCode
Z80InstructionSelector::foldSetCC(MachineInstr &I, MachineIRBuilder &MIB,
                                  MachineRegisterInfo &MRI) const {
  assert(I.getOpcode() == Z80::SetCC && "unexpected instruction");
  auto CC = Z80::CondCode(I.getOperand(1).getImm());

  if (I == MIB.getInsertPt())
    return CC;

  return Z80::COND_INVALID;
}

Z80::CondCode Z80InstructionSelector::foldCond(Register CondReg,
                                               MachineIRBuilder &MIB,
                                               MachineRegisterInfo &MRI) const {
  assert(MRI.getType(CondReg) == LLT::scalar(1) && "Expected s1 condition");

  MachineInstr *CondDef = nullptr;
  while (MachineInstr *LookthroughDef = MRI.getVRegDef(CondReg)) {
    if (LookthroughDef != MIB.getInsertPt() && !MRI.hasOneUse(CondReg))
      break;
    CondDef = LookthroughDef;
    unsigned Opc = CondDef->getOpcode();
    if (Opc != TargetOpcode::COPY && Opc != TargetOpcode::G_TRUNC)
      break;
    Register SrcReg = CondDef->getOperand(1).getReg();
    if (SrcReg.isPhysical())
      break;
    CondReg = SrcReg;
  }

  Z80::CondCode CC = Z80::COND_INVALID;
  if (CondDef) {
    switch (CondDef->getOpcode()) {
    case TargetOpcode::G_ICMP:
      CC = foldCompare(*CondDef, MIB, MRI);
      break;
    case TargetOpcode::G_UADDO:
    case TargetOpcode::G_UADDE:
    case TargetOpcode::G_USUBO:
    case TargetOpcode::G_USUBE:
    case TargetOpcode::G_SADDO:
    case TargetOpcode::G_SADDE:
    case TargetOpcode::G_SSUBO:
    case TargetOpcode::G_SSUBE:
      CC = foldExtendedAddSub(*CondDef, MIB, MRI);
      break;
    case Z80::SetCC:
      CC = foldSetCC(*CondDef, MIB, MRI);
      break;
    default:
      break;
    }
  }

  if (CC == Z80::COND_INVALID) {
    // Fallback to bit test
    auto BitI = MIB.buildInstr(Z80::BIT8bg, {}, {int64_t(0), CondReg});
    if (constrainSelectedInstRegOperands(*BitI, TII, TRI, RBI))
      CC = Z80::COND_NZ;
  }

  return CC;
}

bool Z80InstructionSelector::selectShift(MachineInstr &I,
                                         MachineRegisterInfo &MRI) const {
  assert(I.getOpcode() == Z80::G_ASHR && "Unexpected opcode");
  Register DstReg = I.getOperand(0).getReg();
  Register SrcReg = I.getOperand(1).getReg();
  auto Amt = getConstantVRegValWithLookThrough(I.getOperand(2).getReg(), MRI);
  assert(Amt && "Expected constant shift amount");
  LLT Ty = MRI.getType(DstReg);
  assert(Ty.isScalar() && "Illegal type");
  if (Amt->Value == Ty.getSizeInBits() - 1) {
    MachineIRBuilder MIB(I);
    Register Reg;
    unsigned AddOpc, SbcOpc;
    const TargetRegisterClass *RC;
    switch (Ty.getSizeInBits()) {
    default:
      llvm_unreachable("Illegal type");
    case 8:
      Reg = Z80::A;
      AddOpc = Z80::RLC8r;
      SbcOpc = Z80::SBC8ar;
      RC = &Z80::R8RegClass;
      break;
    case 16:
      Reg = Z80::HL;
      AddOpc = Z80::ADD16aa;
      SbcOpc = Z80::SBC16aa;
      RC = &Z80::R16RegClass;
      break;
    case 24:
      assert(STI.is24Bit() && "Illegal type");
      Reg = Z80::UHL;
      AddOpc = Z80::ADD24aa;
      SbcOpc = Z80::SBC24aa;
      RC = &Z80::R24RegClass;
      break;
    }
    if (Ty != LLT::scalar(8)) {
      MIB.buildCopy(Reg, SrcReg);
      if (!RBI.constrainGenericRegister(SrcReg, *RC, MRI))
        return false;
    }
    auto AddI = MIB.buildInstr(AddOpc, {Ty}, {SrcReg});
    auto SbcI = MIB.buildInstr(SbcOpc);
    if (Ty == LLT::scalar(8)) {
      SbcI->findRegisterUseOperand(Reg)->setIsUndef();
      SbcI.addReg(Reg, RegState::Undef);
    }
    MIB.buildCopy(DstReg, Reg);
    I.eraseFromParent();
    return constrainSelectedInstRegOperands(*AddI, TII, TRI, RBI) &&
           constrainSelectedInstRegOperands(*SbcI, TII, TRI, RBI) &&
           RBI.constrainGenericRegister(DstReg, *RC, MRI);
  }
  llvm_unreachable("Illegal shift amount");
}

bool Z80InstructionSelector::selectFunnelShift(MachineInstr &I,
                                               MachineRegisterInfo &MRI) const {
  bool IsLeft = I.getOpcode() == Z80::G_FSHL;
  assert((IsLeft || I.getOpcode() == Z80::G_FSHR) && "Unexpected opcode");
  Register DstReg = I.getOperand(0).getReg();
  Register HiReg = I.getOperand(1).getReg();
  Register LoReg = I.getOperand(2).getReg();
  auto Amt = getConstantVRegValWithLookThrough(I.getOperand(3).getReg(), MRI);
  LLT Ty = MRI.getType(DstReg);
  assert(Ty == LLT::scalar(8) && "Illegal type");
  assert(Amt && (Amt->Value == 1 || Amt->Value == 7) && "Illegal shift amount");
  IsLeft ^= Amt->Value == 7;
  MachineIRBuilder MIB(I);
  auto ShiftI = MIB.buildInstr(IsLeft ? Z80::RLC8r : Z80::RRC8r, {Ty},
                               {IsLeft ? LoReg : HiReg});
  auto RotateI = MIB.buildInstr(IsLeft ? Z80::RL8r : Z80::RR8r, {DstReg},
                                {IsLeft ? HiReg : LoReg});
  I.eraseFromParent();
  return constrainSelectedInstRegOperands(*ShiftI, TII, TRI, RBI) &&
         constrainSelectedInstRegOperands(*RotateI, TII, TRI, RBI);
}

bool Z80InstructionSelector::selectSetCond(MachineInstr &I,
                                           MachineRegisterInfo &MRI) const {
  Register CondReg = I.getOperand(I.getNumExplicitDefs() - 1).getReg();
  assert(MRI.getType(CondReg) == LLT::scalar(1) && "Expected s1 condition");

  MachineIRBuilder MIB(I);
  Z80::CondCode CC = foldCond(CondReg, MIB, MRI);
  if (CC == Z80::COND_INVALID)
    return false;

  if (MRI.reg_empty(CondReg))
    return true;

  auto TrueI = MIB.buildInstr(Z80::LD8ri, {LLT::scalar(8)}, {int64_t(1)});
  auto FalseI = MIB.buildInstr(Z80::LD8ri, {LLT::scalar(8)}, {int64_t(0)});
  auto SelectI =
      MIB.buildInstr(Z80::Select8, {CondReg}, {TrueI, FalseI, int64_t(CC)});
  I.eraseFromParent();
  return constrainSelectedInstRegOperands(*FalseI, TII, TRI, RBI) &&
         constrainSelectedInstRegOperands(*TrueI, TII, TRI, RBI) &&
         constrainSelectedInstRegOperands(*SelectI, TII, TRI, RBI);
}

bool Z80InstructionSelector::selectSelect(MachineInstr &I,
                                          MachineRegisterInfo &MRI) const {
  assert(I.getOpcode() == TargetOpcode::G_SELECT && "unexpected instruction");

  LLT OpTy = MRI.getType(I.getOperand(2).getReg());
  unsigned Select;
  const TargetRegisterClass *RC;
  switch (OpTy.getSizeInBits()) {
  case 8:
    Select = Z80::Select8;
    RC = &Z80::R8RegClass;
    break;
  case 16:
    Select = Z80::Select16;
    RC = &Z80::R16RegClass;
    break;
  case 24:
    Select = Z80::Select24;
    RC = &Z80::R24RegClass;
    break;
  default:
    return false;
  }

  MachineIRBuilder MIB(I);
  Z80::CondCode CC = foldCond(I.getOperand(1).getReg(), MIB, MRI);
  if (CC == Z80::COND_INVALID)
    return false;

  I.setDesc(TII.get(Select));
  I.getOperand(1).setReg(I.getOperand(2).getReg());
  I.getOperand(2).setReg(I.getOperand(3).getReg());
  I.getOperand(3).ChangeToImmediate(CC);
  return constrainSelectedInstRegOperands(I, TII, TRI, RBI);
}

bool Z80InstructionSelector::selectBrCond(MachineInstr &I,
                                          MachineRegisterInfo &MRI) const {
  assert(I.getOpcode() == TargetOpcode::G_BRCOND && "unexpected instruction");

  MachineIRBuilder MIB(I);
  Z80::CondCode CC = foldCond(I.getOperand(0).getReg(), MIB, MRI);
  if (CC == Z80::COND_INVALID)
    return false;

  MIB.buildInstr(Z80::JQCC).add(I.getOperand(1)).addImm(CC);
  I.eraseFromParent();
  return true;
}

bool Z80InstructionSelector::selectBrJT(MachineInstr &I,
                                        MachineRegisterInfo &MRI,
                                        MachineFunction &MF) const {
  assert((I.getOpcode() == TargetOpcode::G_BRJT) && "unexpected instruction");

  unsigned EntrySize = MF.getJumpTableInfo()->getEntrySize(MF.getDataLayout());
  assert(EntrySize && EntrySize <= 3 &&
         "Jump table entry size is expected to be less than pointer size");

  Register AddrReg = I.getOperand(0).getReg();
  LLT AddrTy = MRI.getType(AddrReg);
  Register IndexReg = I.getOperand(2).getReg();
  MachineIRBuilder MIB(I);

  for (unsigned Factor = 0; Factor != EntrySize; ++Factor) {
    auto Add = MIB.buildInstr(STI.is24Bit() ? Z80::ADD24ao : Z80::ADD16ao,
                              {AddrTy}, {AddrReg, IndexReg});
    if (!constrainSelectedInstRegOperands(*Add, TII, TRI, RBI))
      return false;
    AddrReg = Add.getReg(0);
  }

  auto Load = MIB.buildInstr(STI.is24Bit()
                                 ? Z80::LD24rp
                                 : STI.hasEZ80Ops() ? Z80::LD16rp : Z80::LD88rp,
                             {AddrTy}, {AddrReg});
  if (!constrainSelectedInstRegOperands(*Load, TII, TRI, RBI))
    return false;

  auto Jump =
      MIB.buildInstr(STI.is24Bit() ? Z80::JP24r : Z80::JP16r, {}, {Load});
  if (!constrainSelectedInstRegOperands(*Jump, TII, TRI, RBI))
    return false;

  I.eraseFromParent();
  return true;
}

bool Z80InstructionSelector::selectImplicitDefOrPHI(
    MachineInstr &I, MachineRegisterInfo &MRI) const {
  assert((I.getOpcode() == TargetOpcode::G_IMPLICIT_DEF ||
          I.getOpcode() == TargetOpcode::G_PHI) &&
         "unexpected instruction");

  Register DstReg = I.getOperand(0).getReg();

  if (!MRI.getRegClassOrNull(DstReg)) {
    const LLT DstTy = MRI.getType(DstReg);
    const TargetRegisterClass *RC = getRegClass(DstTy, DstReg, MRI);

    if (!RBI.constrainGenericRegister(DstReg, *RC, MRI))
      return false;
  }

  if (I.getOpcode() == TargetOpcode::G_IMPLICIT_DEF)
    I.setDesc(TII.get(Z80::IMPLICIT_DEF));
  else
    I.setDesc(TII.get(Z80::PHI));

  return true;
}

InstructionSelector::ComplexRendererFns
Z80InstructionSelector::selectMem(MachineOperand &MO) const {
  llvm_unreachable("Unimplemented!");
}

InstructionSelector::ComplexRendererFns
Z80InstructionSelector::selectOff(MachineOperand &MO) const {
  llvm_unreachable("Unimplemented!");
}

InstructionSelector *
llvm::createZ80InstructionSelector(const Z80TargetMachine &TM,
                                   Z80Subtarget &Subtarget,
                                   Z80RegisterBankInfo &RBI) {
  return new Z80InstructionSelector(TM, Subtarget, RBI);
}
